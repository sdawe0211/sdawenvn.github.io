<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Prevent caching to ensure latest version is always loaded -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>VR çƒ¹é£ªéŠæˆ² - åŸå‹ä»‹é¢ v2.1 (é£Ÿææ¬„åº•éƒ¨ç‰ˆ)</title>
    <script>
        const originalWarn = console.warn;
        console.warn = function (...args) {
            if (args[0] && typeof args[0] === 'string') {
                // Filter out Tailwind CSS warnings
                if (args[0].includes('cdn.tailwindcss.com')) return;
                // Filter out FBX loader unsupported texture warnings
                if (args[0].includes('THREE.FBXLoader') &&
                    (args[0].includes('ShininessExponent') || args[0].includes('ReflectionFactor'))) {
                    return;
                }
            }
            originalWarn.apply(console, args);
        };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            font-family: 'Orbitron', sans-serif;
            background: #0a0a0a;
            margin: 0;
            color: white;
        }

        .neon-border {
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.3), inset 0 0 10px rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
        }

        .neon-border-pink {
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.5), 0 0 20px rgba(255, 0, 255, 0.3), inset 0 0 10px rgba(255, 0, 255, 0.2);
            border: 2px solid #ff00ff;
        }

        .neon-border-green {
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5), 0 0 20px rgba(0, 255, 0, 0.3), inset 0 0 10px rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
        }

        .neon-border-yellow {
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.5), 0 0 20px rgba(255, 255, 0, 0.3), inset 0 0 10px rgba(255, 255, 0, 0.2);
            border: 2px solid #ffff00;
        }

        .neon-text {
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8), 0 0 20px rgba(0, 255, 255, 0.5);
        }

        .neon-text-pink {
            text-shadow: 0 0 10px rgba(255, 0, 255, 0.8), 0 0 20px rgba(255, 0, 255, 0.5);
        }

        .neon-text-green {
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.8), 0 0 20px rgba(0, 255, 0, 0.5);
        }

        .neon-text-yellow {
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8), 0 0 20px rgba(255, 255, 0, 0.5);
        }

        .grid-bg {
            background-image:
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
        }

        .screen {
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
        }

        .recipe-card {
            transition: all 0.3s ease;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .recipe-card:hover {
            transform: scale(1.03);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.06);
        }

        .card-body {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            gap: 1rem;
            flex: 1 1 auto;
        }

        .btn-primary {
            background: linear-gradient(135deg, #00ffff 0%, #0080ff 100%);
            transition: all 0.3s ease;
        }

        .outline-btn {
            background: rgba(17, 24, 39, 1);
            width: 20rem;
            padding-top: 1rem;
            padding-bottom: 1rem;
            border-radius: 0.5rem;
            font-size: 1.125rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
            margin-right: auto;
            transition: all .15s ease;
            border: 2px solid rgba(255, 255, 255, 0.06);
        }

        .floating-instruction {
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0)
            }

            50% {
                transform: translateY(-10px)
            }
        }

        .pulse-glow {
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.6
            }

            50% {
                opacity: 1
            }
        }

        .star-field {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {

            0%,
            100% {
                opacity: 0.3
            }

            50% {
                opacity: 1
            }
        }

        /* Three.js container behind UI */
        #three-container {
            position: absolute;
            inset: 0;
            z-index: 0;
            touch-action: none;
            background: #020204;
        }

        /* gameplay UI sits above canvas */
        .ui-above {
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }

        /* top panels */
        .top-panel {
            position: absolute;
            pointer-events: auto;
            z-index: 12;
        }

        /* settings modal */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }

        .modal-backdrop.show {
            display: flex;
        }

        .modal {
            width: 280px;
            background: rgba(6, 6, 8, 0.98);
            border-radius: 12px;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.06);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
            text-align: center;
        }

        .modal .modal-btn {
            width: 100%;
            padding: 10px 12px;
            margin: 6px 0;
            border-radius: 8px;
            background: #111827;
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.06);
            font-weight: 700;
        }

        .modal .modal-btn.primary {
            background: linear-gradient(135deg, #00ffff 0%, #0080ff 100%);
        }

        .modal .modal-btn.danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #d6336c 100%);
        }

        /* remove step indicators and bottom controls via not including them */

        /* responsive tweaks */
        @media (max-width: 640px) {
            .outline-btn {
                width: 90%;
            }

            .card-body {
                padding: 1rem;
            }

            .modal {
                width: 90%;
            }
        }

        /* Music Control Button */
        .music-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(6, 6, 8, 0.9);
            border: 2px solid #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(0, 255, 255, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
            font-size: 24px;
            color: #00ffff;
        }

        .music-control:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .music-control.muted {
            border-color: #ff6b6b;
            color: #ff6b6b;
            box-shadow: 0 0 10px rgba(255, 107, 107, 0.5), 0 0 20px rgba(255, 107, 107, 0.3);
        }

        .music-control.muted:hover {
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.8), 0 0 30px rgba(255, 107, 107, 0.5);
        }

        @media (max-width: 640px) {
            .music-control {
                width: 50px;
                height: 50px;
                font-size: 20px;
                bottom: 15px;
                right: 15px;
            }
        }

        /* Loading Indicator */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.3s ease;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(0, 255, 255, 0.2);
            border-top-color: #00ffff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 20px;
            color: #00ffff;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
    </style>
</head>

<body>
    <!-- Background Music -->
    <audio id="bgMusic" loop preload="auto">
        <source src="assets/audio/chillhop.m4a" type="audio/mp4">
        æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´éŸ³è¨Šæ’­æ”¾ã€‚
    </audio>

    <!-- Success Music (for results screen) -->
    <audio id="successMusic" preload="auto">
        <source src="assets/audio/æˆåŠŸéŸ³æ¨‚.m4a" type="audio/mp4">
        æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´éŸ³è¨Šæ’­æ”¾ã€‚
    </audio>

    <!-- star background -->
    <div class="star-field" aria-hidden="true">
        <div class="star" style="top:10%; left:20%; width:2px; height:2px;"></div>
        <div class="star" style="top:30%; left:80%; width:1px; height:1px;"></div>
        <div class="star" style="top:60%; left:40%; width:2px; height:2px;"></div>
        <div class="star" style="top:80%; left:70%; width:1px; height:1px;"></div>
        <div class="star" style="top:20%; left:60%; width:2px; height:2px;"></div>
    </div>

    <!-- Music Control Button -->
    <button id="musicToggle" class="music-control" aria-label="éŸ³æ¨‚æ§åˆ¶" title="é»æ“Šä»¥åˆ‡æ›éŸ³æ¨‚">
        <i class="fas fa-volume-up"></i>
    </button>

    <!-- 1. ä¸»é¸å–® -->
    <section id="home" class="screen grid-bg flex items-center justify-center">
        <div class="text-center max-w-4xl">
            <h1 class="text-7xl font-black mb-8 neon-text">VR KITCHEN</h1>
            <p class="text-xl mb-12 text-cyan-300">é«”é©—è™›æ“¬çƒ¹é£ªçš„æ¥µè‡´æ¨‚è¶£</p>

            <div class="space-y-6">
                <button id="startBtn" class="outline-btn neon-border py-4 text-xl menu-btn" aria-label="é–‹å§‹éŠæˆ²">
                    <i class="fas fa-play mr-3"></i> é–‹å§‹éŠæˆ²
                </button>

                <button id="settingsBtn" class="outline-btn neon-border-pink py-4 text-xl menu-btn" aria-label="è¨­å®š">
                    <i class="fas fa-cog mr-3"></i> è¨­å®š
                </button>

                <button id="aboutBtn" class="outline-btn neon-border-green py-4 text-xl menu-btn" aria-label="é—œæ–¼">
                    <i class="fas fa-info-circle mr-3"></i> é—œæ–¼
                </button>
            </div>

            <div class="mt-16 flex justify-center gap-8">
                <div class="text-center">
                    <div class="text-4xl neon-text-pink mb-2">2</div>
                    <div class="text-sm text-gray-400">é£Ÿè­œ</div>
                </div>
                <div class="text-center">
                    <div class="text-4xl neon-text-green mb-2">âˆ</div>
                    <div class="text-sm text-gray-400">ç·´ç¿’æ¬¡æ•¸</div>
                </div>
            </div>
        </div>
    </section>

    <!-- 2. é£Ÿè­œé¸æ“‡ -->
    <section id="recipes" class="screen grid-bg">
        <div class="max-w-6xl mx-auto pt-8">
            <h2 class="text-4xl font-bold text-center mb-8 neon-text">
                <i class="fas fa-utensils mr-4"></i>é¸æ“‡ä½ çš„æ–™ç†
            </h2>

            <div class="grid md:grid-cols-2 gap-8">
                <!-- ç•ªèŒ„ç‚’è›‹ -->
                <div class="recipe-card neon-border bg-black bg-opacity-50 rounded-lg overflow-hidden">
                    <div class="h-56 bg-gradient-to-br from-cyan-900 to-blue-900 flex items-center justify-center">
                        <i class="fas fa-egg text-8xl text-cyan-400"></i>
                    </div>
                    <div class="card-body">
                        <div class="card-content">
                            <h3 class="text-2xl font-bold mb-2 neon-text">ç•ªèŒ„ç‚’è›‹</h3>
                            <p class="text-gray-400 mb-3">ç°¡å–®åˆç¶“å…¸çš„å®¶å¸¸èœï¼Œé©åˆç·´ç¿’ç«å€™èˆ‡ç¿»ç‚’ã€‚</p>
                            <div class="flex items-center gap-4 mb-3 text-sm">
                                <span class="flex items-center"><i class="fas fa-clock mr-2 text-cyan-400"></i>ç´„ 5
                                    åˆ†é˜</span>
                                <span class="flex items-center"><i class="fas fa-layer-group mr-2 text-pink-400"></i>5
                                    å€‹æ­¥é©Ÿ</span>
                            </div>
                            <div class="flex gap-2 mb-3 flex-wrap">
                                <span
                                    class="px-3 py-1 bg-cyan-900 bg-opacity-50 rounded text-xs neon-border border-opacity-50">ç•ªèŒ„</span>
                                <span
                                    class="px-3 py-1 bg-cyan-900 bg-opacity-50 rounded text-xs neon-border border-opacity-50">é›è›‹</span>
                                <span
                                    class="px-3 py-1 bg-cyan-900 bg-opacity-50 rounded text-xs neon-border border-opacity-50">é£Ÿç”¨æ²¹</span>
                                <span
                                    class="px-3 py-1 bg-cyan-900 bg-opacity-50 rounded text-xs neon-border border-opacity-50">è”¥èŠ±</span>
                                <span
                                    class="px-3 py-1 bg-cyan-900 bg-opacity-50 rounded text-xs neon-border border-opacity-50">ç³–</span>
                                <span
                                    class="px-3 py-1 bg-cyan-900 bg-opacity-50 rounded text-xs neon-border border-opacity-50">é¹½</span>
                                <span
                                    class="px-3 py-1 bg-cyan-900 bg-opacity-50 rounded text-xs neon-border border-opacity-50">ç•ªèŒ„é†¬</span>
                            </div>
                        </div>

                        <div>
                            <button class="btn-primary w-full py-3 rounded-lg font-bold choose-recipe-btn"
                                data-steps="5">
                                é¸æ“‡æ–™ç†
                            </button>
                        </div>
                    </div>
                </div>

                <!-- å®¢å®¶å°ç‚’ -->
                <div class="recipe-card neon-border-pink bg-black bg-opacity-50 rounded-lg overflow-hidden"
                    style="position: relative; opacity: 0.6; cursor: not-allowed;">
                    <!-- é–‹ç™¼ä¸­æ¨™ç±¤ -->
                    <div
                        style="position: absolute; top: 16px; right: 16px; z-index: 10; background: linear-gradient(135deg, #ff6b6b 0%, #d6336c 100%); padding: 8px 16px; border-radius: 8px; border: 2px solid #ff00ff; box-shadow: 0 0 10px rgba(255, 0, 255, 0.5);">
                        <span class="text-sm font-bold neon-text-pink">ğŸš§ é–‹ç™¼ä¸­</span>
                    </div>

                    <div class="h-56 bg-gradient-to-br from-pink-900 to-purple-900 flex items-center justify-center"
                        style="filter: grayscale(0.3);">
                        <i class="fas fa-bowl-rice text-8xl text-pink-400"></i>
                    </div>
                    <div class="card-body">
                        <div class="card-content">
                            <h3 class="text-2xl font-bold mb-2 neon-text-pink">å®¢å®¶å°ç‚’</h3>
                            <p class="text-gray-400 mb-3">å£å‘³æ¿ƒéƒçš„ä¸‹é£¯èœ,ç·´ç¿’çˆ†é¦™èˆ‡ç«å€™æ§åˆ¶ã€‚</p>
                            <div class="flex items-center gap-4 mb-3 text-sm">
                                <span class="flex items-center"><i class="fas fa-clock mr-2 text-pink-400"></i>ç´„ 8
                                    åˆ†é˜</span>
                                <span class="flex items-center"><i class="fas fa-layer-group mr-2 text-cyan-400"></i>6
                                    å€‹æ­¥é©Ÿ</span>
                            </div>
                            <div class="flex gap-2 mb-3 flex-wrap">
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">äº”èŠ±è‚‰</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">è±†å¹²</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">é­·é­šä¹¾</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">èŠ¹èœ</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">è¾£æ¤’</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">é£Ÿç”¨æ²¹</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">è’œé ­</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">å†°ç³–</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">ç™½èƒ¡æ¤’é¹½</span>
                                <span
                                    class="px-3 py-1 bg-pink-900 bg-opacity-50 rounded text-xs neon-border-pink border-opacity-50">é†¬æ²¹</span>
                            </div>
                        </div>

                        <div>
                            <button
                                class="bg-gray-700 w-full py-3 rounded-lg font-bold border-2 border-gray-600 text-gray-400 cursor-not-allowed hakka-recipe-btn"
                                data-steps="6" style="pointer-events: auto;">
                                é–‹ç™¼ä¸­
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="text-center mt-8">
                <button id="backToHomeBtn"
                    class="px-8 py-3 bg-gray-900 rounded-lg neon-border border-opacity-50 hover:border-opacity-100 transition">
                    <i class="fas fa-arrow-left mr-2"></i> è¿”å›ä¸»é¸å–®
                </button>
            </div>
        </div>
    </section>

    <!-- 3. éŠæˆ²ç•«é¢ (å–®ä¸€å ´æ™¯) -->
    <section id="gameplay" class="screen bg-black relative overflow-hidden">
        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="loading-overlay">
            <div class="loading-spinner"></div>
            <div class="loading-text">è¼‰å…¥å ´æ™¯ä¸­...</div>
        </div>

        <!-- Three.js canvas container -->
        <div id="three-container" aria-hidden="true"></div>

        <!-- top-left: settings (hamburger) -->
        <div class="absolute top-4 left-4 top-panel ui-above" style="z-index:12;">
            <button id="gameSettingsBtn" class="px-3 py-2 neon-border rounded bg-black bg-opacity-70" aria-label="éŠæˆ²è¨­å®š">
                <i class="fas fa-bars"></i>
            </button>
        </div>

        <!-- top-center: SCORE -->
        <div
            class="absolute top-4 left-1/2 transform -translate-x-1/2 top-panel ui-above neon-border-green bg-black bg-opacity-70 px-4 py-2 rounded">
            <div class="text-xs text-green-400 mb-1">SCORE</div>
            <div class="text-xl font-bold neon-text-green score-value">0 / 100</div>
        </div>

        <!-- top-right: TIME -->
        <div class="absolute top-4 right-4 top-panel ui-above neon-border bg-black bg-opacity-70 px-4 py-2 rounded">
            <div class="text-xs text-cyan-400 mb-1">TIME</div>
            <div class="flex items-center gap-3">
                <i class="fas fa-clock text-cyan-400"></i>
                <span class="text-xl font-bold neon-text time-value">00:00</span>
            </div>
        </div>

        <!-- center-top: Cooking Steps Panel -->
        <div class="absolute left-1/2 transform -translate-x-1/2 -translate-y-1/2 ui-above neon-border bg-black bg-opacity-90 rounded-lg p-2"
            style="z-index:12; width: 320px; max-width: 88vw; top: calc(33.333% - 50px);">
            <div class="text-center mb-1">
                <div id="cookingPhaseTitle" class="text-sm font-bold neon-text-pink">ç¬¬ä¸€éšæ®µï¼šæº–å‚™åŸºåº•</div>
            </div>
            <div id="cookingStepsContent" class="space-y-1.5">
                <!-- Step 1 -->
                <div class="flex gap-1.5 p-1.5 bg-black bg-opacity-50 rounded border border-cyan-400 border-opacity-30">
                    <div class="flex-shrink-0">
                        <div class="w-5 h-5 rounded-full bg-cyan-400 bg-opacity-20 flex items-center justify-center">
                            <span class="text-cyan-400 font-bold" style="font-size: 10px;">1</span>
                        </div>
                    </div>
                    <div class="flex-1 leading-tight" style="font-size: 11px;">
                        é•·æŒ‰ä¸‹æ–¹ã€<span class="text-red-400 font-semibold">ç•ªèŒ„</span>ã€‘ï¼Œæ‹–ç§»è‡³ã€<span
                            class="text-yellow-400 font-semibold">ç §æ¿</span>ã€‘ä¸Šæ–¹é¬†é–‹ã€‚ç•ªèŒ„å°‡è‡ªå‹•åˆ‡å¡Šã€‚
                    </div>
                </div>

                <!-- Step 2 -->
                <div class="flex gap-1.5 p-1.5 bg-black bg-opacity-50 rounded border border-cyan-400 border-opacity-30">
                    <div class="flex-shrink-0">
                        <div class="w-5 h-5 rounded-full bg-cyan-400 bg-opacity-20 flex items-center justify-center">
                            <span class="text-cyan-400 font-bold" style="font-size: 10px;">2</span>
                        </div>
                    </div>
                    <div class="flex-1 leading-tight" style="font-size: 11px;">
                        é•·æŒ‰ä¸‹æ–¹ã€<span class="text-cyan-400 font-semibold">é›è›‹</span>ã€‘ï¼Œæ‹–ç§»è‡³ã€<span
                            class="text-gray-300 font-semibold">ç™½è‰²å¤§ç¢—</span>ã€‘å…§é¬†é–‹ã€‚é›è›‹å°‡è‡ªå‹•æ”ªæ‹Œå®Œæˆã€‚
                    </div>
                </div>
            </div>
        </div>

        <!-- bottom-center: Ingredients Panel -->
        <div class="absolute bottom-4 left-1/2 transform -translate-x-1/2 ui-above neon-border-yellow bg-black bg-opacity-80 rounded-lg p-2"
            style="z-index:12; max-width: 90vw;">
            <div class="text-center mb-2">
                <div class="font-bold neon-text-yellow" style="font-size: 12px;">é£Ÿææ¬„</div>
            </div>
            <div id="ingredientsList" class="flex gap-2 flex-wrap justify-center">
                <!-- Ingredients will be added here dynamically -->
            </div>
        </div>

        <!-- drop zone (upload) kept hidden until used -->
        <div id="dropZone" style="display:none;">
            <div class="box">
                <div class="text-lg mb-2">æ”¾ç½® .glb æª”æ¡ˆåˆ°æ­¤è™• æˆ– é»æ“Šä¸Šå‚³</div>
                <input id="fileInput" type="file" accept=".glb,.gltf"
                    style="opacity:0; position:absolute; left:-9999px;">
                <button id="openFileBtn" class="px-4 py-2 bg-gray-900 rounded neon-border">é¸æ“‡æª”æ¡ˆ</button>
            </div>
        </div>

        <!-- settings modal -->
        <div id="settingsModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="modal" role="document">
                <h3 class="text-lg font-bold mb-3 neon-text">é¸å–®</h3>
                <button id="modalContinue" class="modal-btn primary">ç¹¼çºŒ</button>
                <button id="modalAbandon" class="modal-btn danger">æ”¾æ£„</button>
                <button id="modalSettings" class="modal-btn">è¨­å®š</button>
            </div>
        </div>

        <!-- é–‹ç™¼ä¸­æ¨¡æ…‹è¦–çª— -->
        <div id="devModal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
            <div class="modal" role="document">
                <h3 class="text-lg font-bold mb-3 neon-text-pink">ğŸš§ é–‹ç™¼ä¸­</h3>
                <p class="text-gray-300 mb-4">æ­¤æ–™ç†æ­£åœ¨é–‹ç™¼ä¸­ï¼Œæ•¬è«‹æœŸå¾…ï¼</p>
                <button id="devModalClose" class="modal-btn primary">ç¢ºå®š</button>
            </div>
        </div>

        <!-- 4. äº’å‹•æŒ‡å¼• (unchanged) -->
        <section id="interaction" class="screen grid-bg flex items-center justify-center" style="display:none;">
            <div class="max-w-4xl">
                <h2 class="text-4xl font-bold text-center mb-12 neon-text">
                    <i class="fas fa-hand-pointer mr-3"></i>äº’å‹•æŒ‡å¼•ç¯„ä¾‹
                </h2>
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="neon-border bg-black bg-opacity-50 rounded-lg p-6">
                        <h3 class="text-xl font-bold mb-4 neon-text-pink">ç‰©å“é¸å–ä¸­</h3>
                        <div class="relative h-64 flex items-center justify-center">
                            <i class="fas fa-egg text-8xl text-cyan-400 opacity-50"></i>
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="w-32 h-32 border-4 border-cyan-400 rounded-full animate-ping"></div>
                            </div>
                        </div>
                        <div class="mt-4 text-center text-sm text-gray-400">é•·æŒ‰ç‰©å“ 1 ç§’ä»¥é¸å–</div>
                    </div>

                    <div class="neon-border bg-black bg-opacity-50 rounded-lg p-6">
                        <h3 class="text-xl font-bold mb-4 neon-text-green">æ‡¸æµ®æç¤º</h3>
                        <div class="relative h-64 flex items-center justify-center">
                            <i class="fas fa-blender text-8xl text-pink-400"></i>
                            <div class="absolute -top-8 left-1/2 transform -translate-x-1/2 floating-instruction">
                                <div class="neon-border bg-black bg-opacity-90 rounded-lg p-3 w-48">
                                    <div class="text-xs text-cyan-400 mb-1">æœæ±æ©Ÿ</div>
                                    <div class="text-sm">å°‡é£Ÿææ”¾å…¥æ”ªæ‹Œ</div>
                                    <div class="text-xs text-gray-500 mt-2"><i class="fas fa-hand-pointer mr-1"></i>é»æ“Šå•Ÿå‹•
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="mt-4 text-center text-sm text-gray-400">é è¿‘ç‰©å“é¡¯ç¤ºåŠŸèƒ½èªªæ˜</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 5. çµæœç•«é¢ -->
        <section id="result" class="screen grid-bg flex items-center justify-center" style="display:none;">
            <div class="max-w-4xl w-full">
                <div class="text-center mb-12">
                    <div class="text-8xl mb-6">ğŸ‰</div>
                    <h2 class="text-6xl font-bold mb-4 neon-text">æ–™ç†å®Œæˆ!</h2>
                    <p class="text-2xl text-cyan-400">ä½ æˆåŠŸè£½ä½œäº†æ–™ç†</p>
                </div>
                <div class="neon-border bg-black bg-opacity-50 rounded-lg p-8 mb-8">
                    <div class="text-center mb-8">
                        <div class="text-7xl font-black neon-text-green mb-2">85</div>
                        <div class="text-xl text-gray-400">ç¸½åˆ†</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Three.js + loaders + controls (ESM via Import Map) -->
        <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
            }
        }
    </script>
        <script type="module">
            import * as THREE from 'three';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
            import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
            import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

            /* Three.js scene + game API (single scene used for all recipes) */
            (function () {
                const container = document.getElementById('three-container');
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x020204);

                const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true, powerPreference: 'high-performance' });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 1.2));
                renderer.setSize(container.clientWidth || window.innerWidth, container.clientHeight || window.innerHeight);
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                container.appendChild(renderer.domElement);

                const camera = new THREE.PerspectiveCamera(50, (container.clientWidth || window.innerWidth) / (container.clientHeight || window.innerHeight), 0.1, 1000);
                camera.position.set(0, 1.6, 3);

                const hemi = new THREE.HemisphereLight(0xffffff, 0x222222, 0.6);
                scene.add(hemi);
                const ambient = new THREE.AmbientLight(0xffffff, 0.8); // Add strong ambient light to ensure visibility
                scene.add(ambient);
                const dir = new THREE.DirectionalLight(0xffffff, 0.8);
                dir.position.set(2, 5, 2);
                scene.add(dir);

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.08;
                controls.enablePan = false;
                controls.minDistance = 0.5;
                controls.maxDistance = 10;
                controls.autoRotate = false; // Disable auto-rotation

                // Create grid texture for floor and walls (black base with cyan grid lines)
                function createGridTexture() {
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');

                    // Black background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, 512, 512);

                    // Cyan grid lines
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3;

                    const gridSize = 32; // 8x8 grid
                    for (let i = 0; i <= 256; i += gridSize) {
                        // Vertical lines
                        ctx.beginPath();
                        ctx.moveTo(i, 0);
                        ctx.lineTo(i, 256);
                        ctx.stroke();

                        // Horizontal lines
                        ctx.beginPath();
                        ctx.moveTo(0, i);
                        ctx.lineTo(256, i);
                        ctx.stroke();
                    }

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.wrapS = THREE.RepeatWrapping;
                    texture.wrapT = THREE.RepeatWrapping;
                    texture.repeat.set(4, 4);
                    return texture;
                }

                // Create floor
                const floorTexture = createGridTexture();
                const floorGeometry = new THREE.PlaneGeometry(50, 50);
                const floorMaterial = new THREE.MeshStandardMaterial({
                    map: floorTexture,
                    roughness: 0.8,
                    metalness: 0.2,
                    emissive: new THREE.Color(0x001a1a),
                    emissiveIntensity: 0.2
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.set(0, -3.02, 0);
                floor.receiveShadow = true;
                scene.add(floor);

                // Create back wall
                const backWallTexture = createGridTexture();
                const backWallGeometry = new THREE.PlaneGeometry(50, 20);
                const backWallMaterial = new THREE.MeshStandardMaterial({
                    map: backWallTexture,
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: new THREE.Color(0x001a1a),
                    emissiveIntensity: 0.15
                });
                const backWall = new THREE.Mesh(backWallGeometry, backWallMaterial);
                backWall.position.set(0, -3.02, -1.69);
                scene.add(backWall);

                // Create left wall
                const leftWallTexture = createGridTexture();
                const leftWallGeometry = new THREE.PlaneGeometry(50, 20);
                const leftWallMaterial = new THREE.MeshStandardMaterial({
                    map: leftWallTexture,
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: new THREE.Color(0x001a1a),
                    emissiveIntensity: 0.15
                });
                const leftWall = new THREE.Mesh(leftWallGeometry, leftWallMaterial);
                leftWall.rotation.y = Math.PI / 2;
                leftWall.position.set(-10, -3.02, 0);
                scene.add(leftWall);

                // Create right wall
                const rightWallTexture = createGridTexture();
                const rightWallGeometry = new THREE.PlaneGeometry(50, 20);
                const rightWallMaterial = new THREE.MeshStandardMaterial({
                    map: rightWallTexture,
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: new THREE.Color(0x001a1a),
                    emissiveIntensity: 0.15
                });
                const rightWall = new THREE.Mesh(rightWallGeometry, rightWallMaterial);
                rightWall.rotation.y = -Math.PI / 2;
                rightWall.position.set(10, -3.02, 0);
                scene.add(rightWall);

                // Create ceiling
                const ceilingTexture = createGridTexture();
                const ceilingGeometry = new THREE.PlaneGeometry(50, 50);
                const ceilingMaterial = new THREE.MeshStandardMaterial({
                    map: ceilingTexture,
                    roughness: 0.9,
                    metalness: 0.1,
                    emissive: new THREE.Color(0x001a1a),
                    emissiveIntensity: 0.15,
                    side: THREE.DoubleSide
                });
                const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.set(0, 6.98, 0);
                scene.add(ceiling);

                function onWindowResize() {
                    const w = container.clientWidth || window.innerWidth;
                    const h = container.clientHeight || window.innerHeight;
                    camera.aspect = w / h;
                    camera.updateProjectionMatrix();
                    renderer.setSize(w, h);
                }
                window.addEventListener('resize', onWindowResize);

                // ===== ç›¸æ©Ÿæ§åˆ¶èªªæ˜ =====
                // ä½¿ç”¨ OrbitControls è®“ç©å®¶å¯ä»¥æ—‹è½‰è¦–è§’
                // é›»è…¦ç«¯ï¼šæŒ‰ä½æ»‘é¼ å·¦éµæ‹–æ›³æ—‹è½‰
                // æ‰‹æ©Ÿç«¯ï¼šå–®æŒ‡æ»‘å‹•æ—‹è½‰
                console.log('ğŸ® ç›¸æ©Ÿæ§åˆ¶ï¼š');
                console.log('  - é›»è…¦ç«¯ï¼šæŒ‰ä½æ»‘é¼ å·¦éµæ‹–æ›³æ—‹è½‰è¦–è§’');
                console.log('  - æ‰‹æ©Ÿç«¯ï¼šå–®æŒ‡æ»‘å‹•æ—‹è½‰è¦–è§’');
                console.log('  - æ»¾è¼ªï¼šç¸®æ”¾è¦–è§’');



                const dracoLoader = new DRACOLoader();
                const gltfLoader = new GLTFLoader();
                gltfLoader.setDRACOLoader(dracoLoader);
                const fbxLoader = new FBXLoader();

                let currentModel = null;
                function disposeCurrentModel() {
                    if (!currentModel) return;
                    currentModel.traverse(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) child.material.forEach(m => m.dispose && m.dispose());
                                else child.material.dispose && child.material.dispose();
                            }
                        }
                    });
                    scene.remove(currentModel);
                    currentModel = null;
                }

                function loadGLBFromURL(url) {
                    disposeCurrentModel();
                    gltfLoader.load(url, (gltf) => {
                        currentModel = gltf.scene;
                        scene.add(gltf.scene);
                        tryFitCameraToObject(gltf.scene);
                    }, undefined, (err) => {
                        console.error('GLB load error', err);
                    });
                }

                function loadGLBFromArrayBuffer(arraybuffer) {
                    disposeCurrentModel();
                    gltfLoader.parse(arraybuffer, '', (gltf) => {
                        currentModel = gltf.scene;
                        scene.add(gltf.scene);
                        tryFitCameraToObject(gltf.scene);
                    }, (err) => {
                        console.error('GLB parse error', err);
                    });
                }

                function tryFitCameraToObject(obj) {
                    const box = new THREE.Box3().setFromObject(obj);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 10.0; // Zoom out even further (10x) to see everything
                    camera.position.set(center.x, center.y + size.y * 2.0, center.z + cameraZ); // Higher vantage point
                    camera.lookAt(center);
                    controls.target.copy(center);
                    controls.update();
                }

                // try default path
                // try default path
                function loadFBXFromURL(url) {
                    disposeCurrentModel();
                    fbxLoader.load(url, (object) => {
                        object.scale.set(0.05, 0.05, 0.05); // Shrink model to 5%
                        currentModel = object;
                        scene.add(object);

                        // Calculate and log model bounding box
                        const box = new THREE.Box3().setFromObject(object);
                        const min = box.min;
                        const max = box.max;
                        const size = box.getSize(new THREE.Vector3());
                        const center = box.getCenter(new THREE.Vector3());

                        console.log('=== å»šæˆ¿æ¨¡å‹é‚Šç•Œè³‡è¨Š ===');
                        console.log('æœ€å°åº§æ¨™ (min):', `X: ${min.x.toFixed(2)}, Y: ${min.y.toFixed(2)}, Z: ${min.z.toFixed(2)}`);
                        console.log('æœ€å¤§åº§æ¨™ (max):', `X: ${max.x.toFixed(2)}, Y: ${max.y.toFixed(2)}, Z: ${max.z.toFixed(2)}`);
                        console.log('å°ºå¯¸ (size):', `å¯¬: ${size.x.toFixed(2)}, é«˜: ${size.y.toFixed(2)}, æ·±: ${size.z.toFixed(2)}`);
                        console.log('ä¸­å¿ƒé» (center):', `X: ${center.x.toFixed(2)}, Y: ${center.y.toFixed(2)}, Z: ${center.z.toFixed(2)}`);
                        console.log('æ¨¡å‹æœ€åº•éƒ¨ Y åº§æ¨™:', min.y.toFixed(2));
                        console.log('æ¨¡å‹æœ€åº•éƒ¨ Z åº§æ¨™:', min.z.toFixed(2));
                        console.log('=======================');

                        // Set fixed camera position to view entire kitchen
                        camera.position.set(0, 0.8, 5);
                        camera.lookAt(0, 0.25, 0);
                        controls.target.set(0, 0.25, 0);
                        controls.update();

                        console.log('Model loaded successfully');
                    }, (xhr) => {
                        // progress
                        if (xhr.lengthComputable) {
                            const percentComplete = xhr.loaded / xhr.total * 100;
                            console.log(Math.round(percentComplete, 2) + '% downloaded');
                        }
                    }, (err) => {
                        console.error('FBX load error', err);
                    });
                }

                // ===== å„ªåŒ–çš„è¼‰å…¥ç³»çµ± =====
                const loadingOverlay = document.getElementById('loadingOverlay');
                const loadingText = loadingOverlay.querySelector('.loading-text');

                // è¼‰å…¥é€²åº¦è¿½è¹¤ï¼ˆåªè¼‰å…¥åŸºæœ¬å ´æ™¯ï¼Œé£Ÿæå»¶é²è¼‰å…¥ï¼‰
                let totalModelsToLoad = 3; // Kitchen, cutting board, plate
                let modelsLoaded = 0;
                let currentLoadingModel = '';

                function updateLoadingProgress(modelName) {
                    modelsLoaded++;
                    const percent = Math.round((modelsLoaded / totalModelsToLoad) * 100);
                    loadingText.textContent = `è¼‰å…¥ä¸­... ${percent}% (${modelsLoaded}/${totalModelsToLoad})`;
                    console.log(`âœ“ ${modelName} è¼‰å…¥å®Œæˆ (${modelsLoaded}/${totalModelsToLoad})`);

                    if (modelsLoaded >= totalModelsToLoad) {
                        loadingText.textContent = 'è¼‰å…¥å®Œæˆï¼';
                        setTimeout(() => {
                            loadingOverlay.classList.add('hidden');
                            console.log('ğŸ‰ åŸºæœ¬å ´æ™¯è¼‰å…¥å®Œæˆï¼');
                        }, 300);
                    }
                }

                function onModelLoadError(modelName) {
                    console.error(`âœ— ${modelName} è¼‰å…¥å¤±æ•—`);
                    updateLoadingProgress(modelName); // ä»ç„¶è¨ˆæ•¸ä»¥é¿å…å¡ä½
                }

                // è¼‰å…¥å»šæˆ¿å ´æ™¯
                loadingText.textContent = 'è¼‰å…¥å»šæˆ¿å ´æ™¯...';
                const defaultSceneURL = 'assets/model/kitchen/Meshy_AI_Neon_Kitchen_Lines_1218020425_texture.fbx';
                fbxLoader.load(defaultSceneURL, (object) => {
                    object.scale.set(0.05, 0.05, 0.05);
                    currentModel = object;
                    scene.add(object);
                    camera.position.set(0, 0.8, 5);
                    camera.lookAt(0, 0.25, 0);
                    controls.target.set(0, 0.25, 0);
                    controls.update();
                    updateLoadingProgress('å»šæˆ¿å ´æ™¯');
                }, undefined, () => onModelLoadError('å»šæˆ¿å ´æ™¯'));

                // è¼‰å…¥ç §æ¿
                let cuttingBoardModel = null;
                const cuttingBoardURL = 'assets/model/ç §æ¿.glb';
                gltfLoader.load(cuttingBoardURL, (gltf) => {
                    cuttingBoardModel = gltf.scene;
                    cuttingBoardModel.scale.set(1, 1, 1);
                    cuttingBoardModel.position.set(-2.5, -0.83, -0.5);
                    cuttingBoardModel.rotation.y = Math.PI;
                    cuttingBoardModel.name = 'cuttingBoard';
                    scene.add(cuttingBoardModel);
                    updateLoadingProgress('ç §æ¿');
                }, undefined, () => onModelLoadError('ç §æ¿'));

                // è¼‰å…¥ç›¤å­
                let plateModel = null;
                const plateURL = 'assets/model/ç›¤å­.glb';
                gltfLoader.load(plateURL, (gltf) => {
                    plateModel = gltf.scene;
                    plateModel.scale.set(1, 1, 1);
                    plateModel.position.set(-3.8, -0.83, -0.5);
                    plateModel.name = 'plate';
                    scene.add(plateModel);
                    updateLoadingProgress('ç›¤å­');
                }, undefined, () => onModelLoadError('ç›¤å­'));

                // Function to render 3D model to 2D image using Orthographic Camera
                function render3DModelTo2D(model, size = 128) {
                    // Create a separate scene for rendering
                    const renderScene = new THREE.Scene();
                    renderScene.background = new THREE.Color(0xffffff); // White background

                    // Clone the model to avoid affecting the original
                    const modelClone = model.clone();
                    renderScene.add(modelClone);

                    // Add strong lighting for the render
                    const renderLight1 = new THREE.DirectionalLight(0xffffff, 2);
                    renderLight1.position.set(0, 0, 5);
                    renderScene.add(renderLight1);

                    const renderLight2 = new THREE.DirectionalLight(0xffffff, 1);
                    renderLight2.position.set(0, 5, 0);
                    renderScene.add(renderLight2);

                    const renderLight3 = new THREE.AmbientLight(0xffffff, 2);
                    renderScene.add(renderLight3);

                    // Calculate bounding box and center the model
                    const box = new THREE.Box3().setFromObject(modelClone);
                    const center = box.getCenter(new THREE.Vector3());
                    const boxSize = box.getSize(new THREE.Vector3());

                    modelClone.position.sub(center); // Center the model
                    // NO rotation - keep model in original orientation

                    // Create orthographic camera for flat 2D rendering
                    const maxDim = Math.max(boxSize.x, boxSize.y, boxSize.z);
                    const frustumSize = maxDim * 1.2; // Add some padding
                    const aspect = 1; // Square aspect ratio

                    const renderCamera = new THREE.OrthographicCamera(
                        frustumSize * aspect / -2,  // left
                        frustumSize * aspect / 2,   // right
                        frustumSize / 2,            // top
                        frustumSize / -2,           // bottom
                        0.1,                        // near
                        1000                        // far
                    );

                    // Position camera directly in front (no angle)
                    renderCamera.position.set(0, 0, 10);
                    renderCamera.lookAt(0, 0, 0);

                    // Create renderer for offscreen rendering
                    const renderTarget = new THREE.WebGLRenderTarget(size, size, {
                        alpha: false,
                        antialias: true,
                        format: THREE.RGBAFormat
                    });

                    // Store current render target
                    const currentRenderTarget = renderer.getRenderTarget();

                    renderer.setRenderTarget(renderTarget);
                    renderer.setClearColor(0xffffff, 1);
                    renderer.clear();
                    renderer.render(renderScene, renderCamera);

                    // Read pixels and create canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = size;
                    canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Get image data from render target
                    const pixels = new Uint8Array(size * size * 4);
                    renderer.readRenderTargetPixels(renderTarget, 0, 0, size, size, pixels);

                    // Create ImageData and flip vertically (WebGL renders upside down)
                    const imageData = ctx.createImageData(size, size);
                    for (let y = 0; y < size; y++) {
                        for (let x = 0; x < size; x++) {
                            const srcIdx = (y * size + x) * 4;
                            const dstIdx = ((size - 1 - y) * size + x) * 4;
                            imageData.data[dstIdx] = pixels[srcIdx];
                            imageData.data[dstIdx + 1] = pixels[srcIdx + 1];
                            imageData.data[dstIdx + 2] = pixels[srcIdx + 2];
                            imageData.data[dstIdx + 3] = pixels[srcIdx + 3];
                        }
                    }

                    ctx.putImageData(imageData, 0, 0);

                    // Restore original render target
                    renderer.setRenderTarget(currentRenderTarget);

                    // Clean up
                    renderTarget.dispose();
                    renderScene.clear();

                    return canvas.toDataURL('image/png');
                }

                // ===== é£Ÿæå»¶é²è¼‰å…¥ç³»çµ± =====
                const ingredientsList = document.getElementById('ingredientsList');
                const ingredients = [
                    { name: 'ç•ªèŒ„', icon: 'fa-apple-alt', color: 'text-red-400', modelPath: 'assets/model/ç•ªèŒ„.glb' },
                    { name: 'é›è›‹', icon: 'fa-egg', color: 'text-cyan-400', modelPath: 'assets/model/é›è›‹.glb' },
                    { name: 'èª¿å‘³ç½', icon: 'fa-jar', color: 'text-yellow-400', modelPath: 'assets/model/èª¿å‘³ç½.glb' },
                    { name: 'é†¬æ²¹ç½', icon: 'fa-bottle-droplet', color: 'text-amber-700', modelPath: 'assets/model/é†¬æ²¹ç½.glb' },
                    { name: 'è”¥èŠ±', icon: 'fa-leaf', color: 'text-green-400', modelPath: 'assets/model/è”¥èŠ±.glb' }
                ];

                // é£Ÿæè¼‰å…¥ç‹€æ…‹
                let ingredientsLoaded = false;
                let ingredientModelsCache = {}; // å¿«å–å·²è¼‰å…¥çš„é£Ÿææ¨¡å‹

                // å»¶é²è¼‰å…¥é£Ÿæï¼ˆé¸æ“‡æ–™ç†å¾Œæ‰èª¿ç”¨ï¼‰
                function loadIngredients() {
                    if (ingredientsLoaded) {
                        console.log('âœ“ é£Ÿæå·²è¼‰å…¥ï¼Œè·³é');
                        return Promise.resolve();
                    }

                    console.log('ğŸ³ é–‹å§‹è¼‰å…¥é£Ÿæ...');
                    loadingOverlay.classList.remove('hidden');
                    loadingText.textContent = 'è¼‰å…¥é£Ÿæä¸­... 0%';

                    let ingredientsLoadedCount = 0;
                    const totalIngredients = ingredients.length;

                    return new Promise((resolve) => {
                        ingredients.forEach((ingredient, index) => {
                            // å‰µå»ºé£Ÿæé …ç›®ï¼ˆå…ˆé¡¯ç¤ºåœ–ç¤ºï¼Œæ¨¡å‹ç¨å¾Œè¼‰å…¥ï¼‰
                            createIngredientItem(ingredient);

                            // è¼‰å…¥é£Ÿææ¨¡å‹
                            gltfLoader.load(ingredient.modelPath, (gltf) => {
                                ingredientModelsCache[ingredient.name] = gltf.scene;
                                ingredientsLoadedCount++;

                                const percent = Math.round((ingredientsLoadedCount / totalIngredients) * 100);
                                loadingText.textContent = `è¼‰å…¥é£Ÿæä¸­... ${percent}% (${ingredientsLoadedCount}/${totalIngredients})`;
                                console.log(`âœ“ ${ingredient.name} è¼‰å…¥å®Œæˆ`);

                                if (ingredientsLoadedCount >= totalIngredients) {
                                    ingredientsLoaded = true;
                                    loadingText.textContent = 'é£Ÿæè¼‰å…¥å®Œæˆï¼';
                                    setTimeout(() => {
                                        loadingOverlay.classList.add('hidden');
                                        console.log('ğŸ‰ æ‰€æœ‰é£Ÿæè¼‰å…¥å®Œæˆï¼');
                                        resolve();
                                    }, 300);
                                }
                            }, undefined, (err) => {
                                console.error(`âœ— ${ingredient.name} è¼‰å…¥å¤±æ•—:`, err);
                                ingredientsLoadedCount++;

                                if (ingredientsLoadedCount >= totalIngredients) {
                                    ingredientsLoaded = true;
                                    setTimeout(() => {
                                        loadingOverlay.classList.add('hidden');
                                        resolve();
                                    }, 300);
                                }
                            });
                        });
                    });
                }

                // å‰µå»ºé£Ÿæé …ç›®ï¼ˆUIï¼‰
                function createIngredientItem(ingredient) {
                    // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
                    const existing = ingredientsList.querySelector(`[data-ingredient="${ingredient.name}"]`);
                    if (existing) return;

                    const ingredientItem = document.createElement('div');
                    ingredientItem.className = 'ingredient-item neon-border-yellow border-opacity-50 rounded p-2 bg-black bg-opacity-50 hover:bg-opacity-70 transition cursor-pointer';
                    ingredientItem.style.minHeight = '48px';
                    ingredientItem.setAttribute('data-ingredient', ingredient.name);
                    ingredientItem.innerHTML = `
                        <div class="flex items-center justify-center gap-1.5 flex-col">
                            <i class="fas ${ingredient.icon} ${ingredient.color}" style="font-size: 18px;"></i>
                            <div style="font-size: 9px; line-height: 1.2;">${ingredient.name}</div>
                        </div>
                    `;

                    // æ·»åŠ äº’å‹•äº‹ä»¶ï¼ˆç¨å¾Œå¯¦ä½œï¼‰
                    setupIngredientInteraction(ingredientItem, ingredient);

                    ingredientsList.appendChild(ingredientItem);
                }

                // Drag and drop state
                let isDragging = false;
                let draggedModel = null;
                let draggedIngredientName = null;
                let draggedIngredientElement = null;
                let longPressTimer = null;
                const LONG_PRESS_DURATION = 200; // 200ms for long press (faster for mobile)

                // è¨­ç½®é£Ÿæäº’å‹•äº‹ä»¶
                function setupIngredientInteraction(ingredientItem, ingredient) {
                    // Add hover effect for border glow
                    ingredientItem.addEventListener('mouseenter', () => {
                        if (!isDragging) {
                            ingredientItem.style.boxShadow = '0 0 15px rgba(0, 255, 255, 0.8), 0 0 30px rgba(0, 255, 255, 0.5), inset 0 0 15px rgba(0, 255, 255, 0.3)';
                        }
                    });

                    ingredientItem.addEventListener('mouseleave', () => {
                        ingredientItem.style.boxShadow = '';
                    });

                    // Long press detection for mouse
                    ingredientItem.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        longPressTimer = setTimeout(() => {
                            startDragging(ingredient, ingredientItem, e.clientX, e.clientY);
                        }, LONG_PRESS_DURATION);
                    });

                    ingredientItem.addEventListener('mouseup', () => {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    });

                    // Long press detection for touch
                    ingredientItem.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        longPressTimer = setTimeout(() => {
                            startDragging(ingredient, ingredientItem, touch.clientX, touch.clientY);
                        }, LONG_PRESS_DURATION);
                    });

                    ingredientItem.addEventListener('touchend', () => {
                        if (longPressTimer) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                        }
                    });
                }


                // Start dragging functionï¼ˆä½¿ç”¨å¿«å–çš„æ¨¡å‹ï¼‰
                function startDragging(ingredient, ingredientElement, clientX, clientY) {
                    console.log(`Starting drag for ${ingredient.name}`);
                    isDragging = true;
                    draggedIngredientName = ingredient.name;
                    draggedIngredientElement = ingredientElement;

                    // ä½¿ç”¨å¿«å–çš„æ¨¡å‹ï¼ˆå·²åœ¨ loadIngredients ä¸­è¼‰å…¥ï¼‰
                    const cachedModel = ingredientModelsCache[ingredient.name];
                    if (cachedModel) {
                        // è¤‡è£½æ¨¡å‹ï¼ˆé¿å…å½±éŸ¿å¿«å–ï¼‰
                        draggedModel = cachedModel.clone();

                        // Set scale based on ingredient type
                        let scale = 0.2; // Default scale
                        if (ingredient.name === 'ç•ªèŒ„') {
                            scale = 0.15; // 25% smaller
                        }
                        draggedModel.scale.set(scale, scale, scale);

                        // Position model at mouse/touch position
                        updateDraggedModelPosition(clientX, clientY);

                        scene.add(draggedModel);

                        // Hide ingredient from panel immediately
                        ingredientElement.style.display = 'none';

                        console.log(`âœ“ ${ingredient.name} æ¨¡å‹å·²æ·»åŠ åˆ°å ´æ™¯`);
                    } else {
                        console.error(`âœ— ${ingredient.name} æ¨¡å‹æœªè¼‰å…¥`);
                        isDragging = false;
                        draggedIngredientName = null;
                        draggedIngredientElement = null;
                    }
                }

                // Start dragging a model that's already in the scene (for phase 2)
                function startDraggingSceneModel(model, clientX, clientY) {
                    console.log(`Starting drag for scene model: ${model.userData.ingredientName}`);
                    isDragging = true;
                    draggedModel = model;
                    draggedIngredientName = model.userData.ingredientName;
                    draggedIngredientElement = null; // No panel element for scene models

                    // Disable OrbitControls during dragging
                    controls.enabled = false;

                    // Store original position for potential return
                    if (!model.userData.originalPosition) {
                        model.userData.originalPosition = model.position.clone();
                    }

                    // Update position to follow cursor
                    updateDraggedModelPosition(clientX, clientY);

                    console.log(`${model.userData.ingredientName} scene model now dragging`);
                }

                // Update dragged model position
                function updateDraggedModelPosition(clientX, clientY) {
                    if (!draggedModel) return;

                    // Convert screen coordinates to 3D world position
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((clientY - rect.top) / rect.height) * 2 + 1;

                    // Create a raycaster from camera through mouse position
                    const vector = new THREE.Vector3(x, y, 0.5);
                    vector.unproject(camera);
                    const dir = vector.sub(camera.position).normalize();

                    // For scene models (è›‹æ¶², ç•ªèŒ„å¡Š), maintain original depth
                    // For panel ingredients, use fixed distance
                    let distance;
                    if (draggedIngredientElement) {
                        // Panel ingredient - use fixed distance
                        distance = 2;
                    } else {
                        // Scene model - calculate distance to maintain original depth
                        const originalZ = draggedModel.userData.originalPosition.z;
                        const cameraToOriginal = draggedModel.userData.originalPosition.clone().sub(camera.position);
                        distance = cameraToOriginal.length();
                    }

                    const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                    draggedModel.position.copy(pos);
                }

                // Check if user clicked on a draggable scene model
                function checkSceneModelClick(clientX, clientY) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((clientY - rect.top) / rect.height) * 2 + 1;

                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(new THREE.Vector2(x, y), camera);

                    // Check all objects in the scene
                    const intersects = raycaster.intersectObjects(scene.children, true);

                    for (let i = 0; i < intersects.length; i++) {
                        let object = intersects[i].object;

                        // Traverse up to find the root model
                        while (object.parent && object.parent.type !== 'Scene') {
                            object = object.parent;
                        }

                        // Check if this model is draggable
                        if (object.userData && object.userData.isDraggable) {
                            console.log(`Clicked on draggable model: ${object.userData.ingredientName}`);
                            startDraggingSceneModel(object, clientX, clientY);
                            return;
                        }
                    }
                }

                // Mouse down handler - check if clicking on draggable scene model
                window.addEventListener('mousedown', (e) => {
                    if ((currentPhase === 2 || currentPhase === 3) && !isDragging) {
                        checkSceneModelClick(e.clientX, e.clientY);
                    }
                });

                // Touch start handler for scene models
                window.addEventListener('touchstart', (e) => {
                    if ((currentPhase === 2 || currentPhase === 3) && !isDragging && e.touches.length > 0) {
                        const touch = e.touches[0];
                        checkSceneModelClick(touch.clientX, touch.clientY);
                    }
                });

                // Mouse move handler
                window.addEventListener('mousemove', (e) => {
                    if (isDragging && draggedModel) {
                        updateDraggedModelPosition(e.clientX, e.clientY);
                    }
                });

                // Touch move handler
                window.addEventListener('touchmove', (e) => {
                    if (isDragging && draggedModel && e.touches.length > 0) {
                        const touch = e.touches[0];
                        updateDraggedModelPosition(touch.clientX, touch.clientY);
                    }
                });

                // Mouse up handler - check if dropped on interactive object
                window.addEventListener('mouseup', (e) => {
                    if (isDragging && draggedModel) {
                        checkDropTarget(e.clientX, e.clientY);
                    }
                });

                // Touch end handler
                window.addEventListener('touchend', (e) => {
                    if (isDragging && draggedModel) {
                        const touch = e.changedTouches[0];
                        checkDropTarget(touch.clientX, touch.clientY);
                    }
                });


                // Game phase and step tracking
                let currentPhase = 1; // Track current phase (1: preparation, 2: cooking)
                let phase1Completed = {
                    eggLiquid: false,
                    tomatoChunks: false
                };
                let currentGameStep = 1; // Track current step (1, 2, 3, etc.)

                // Phase 2: Track what has been added to the pan
                let phase2PanCollection = {
                    eggLiquid: false,
                    tomatoChunks: false,
                    seasoning: false,
                    soySauce: false
                };

                // Step requirements definition
                const stepRequirements = {
                    // Phase 1: Preparation
                    1: { ingredient: 'é›è›‹', target: 'bowl', targetName: 'ç™½è‰²é™¶ç“·ç¢—', resultModel: 'eggLiquid', phase: 1 },
                    2: { ingredient: 'ç•ªèŒ„', target: 'cuttingBoard', targetName: 'ç §æ¿', resultModel: 'tomatoChunks', phase: 1 },
                    // Phase 2: Cooking (draggable models to pan)
                    3: { ingredient: 'è›‹æ¶²', target: 'pan', targetName: 'å¹³åº•é‹', isDraggableModel: true, phase: 2 },
                    4: { ingredient: 'ç•ªèŒ„å¡Š', target: 'pan', targetName: 'å¹³åº•é‹', isDraggableModel: true, phase: 2 },
                    5: { ingredient: 'èª¿å‘³ç½', target: 'pan', targetName: 'å¹³åº•é‹', phase: 2 },
                    6: { ingredient: 'é†¬æ²¹ç½', target: 'pan', targetName: 'å¹³åº•é‹', phase: 2 },
                    // Phase 3: Finishing
                    7: { ingredient: 'è”¥èŠ±', target: 'pan', targetName: 'å¹³åº•é‹', phase: 3 },
                    8: { ingredient: 'æˆå“', target: 'plate', targetName: 'ç›¤å­', isDraggableModel: true, phase: 3 },
                    // Add more steps as needed
                };

                // Check if dropped on interactive object
                function checkDropTarget(clientX, clientY) {
                    const rect = renderer.domElement.getBoundingClientRect();
                    const x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    const y = -((clientY - rect.top) / rect.height) * 2 + 1;

                    // Create raycaster for drop detection
                    const dropRaycaster = new THREE.Raycaster();
                    const mouseVec = new THREE.Vector2(x, y);
                    dropRaycaster.setFromCamera(mouseVec, camera);

                    // Check intersection with interactive objects
                    const interactiveObjects = [
                        { model: cuttingBoardModel, name: 'cuttingBoard' },
                        { model: bowlModel, name: 'bowl' },
                        { model: plateModel, name: 'plate' },
                        { model: panModel, name: 'pan' }
                    ];

                    let droppedOnTarget = false;
                    let targetObject = null;
                    let targetName = null;

                    for (const obj of interactiveObjects) {
                        if (!obj.model) continue;

                        const intersects = dropRaycaster.intersectObject(obj.model, true);
                        if (intersects.length > 0) {
                            droppedOnTarget = true;
                            targetObject = obj.model;
                            targetName = obj.name;
                            break;
                        }
                    }

                    if (droppedOnTarget) {
                        // Check if this matches ANY valid step requirement AND current phase
                        let matchedStepReq = null;

                        // Search through all step requirements to find a match
                        for (let stepNum in stepRequirements) {
                            const req = stepRequirements[stepNum];
                            // Match ingredient, target, AND phase
                            if (draggedIngredientName === req.ingredient &&
                                targetName === req.target &&
                                req.phase === currentPhase) {
                                matchedStepReq = req;
                                break;
                            }
                        }

                        if (matchedStepReq) {
                            // CORRECT! 
                            console.log(`âœ“ Correct! ${draggedIngredientName} dropped on ${targetName}`);

                            // Phase 1: Show timer and load result model
                            if (matchedStepReq.phase === 1) {
                                showTimerAnimation(targetObject, 3000); // 3 seconds timer

                                // Capture matched requirement before setTimeout
                                const capturedStepReq = matchedStepReq;

                                // After timer completes, load result model
                                setTimeout(() => {
                                    console.log('[DEBUG] Timer completed!');
                                    console.log('[DEBUG] Loading result model:', capturedStepReq.resultModel);

                                    // Load appropriate result model based on matched step
                                    if (capturedStepReq.resultModel === 'eggLiquid') {
                                        loadEggLiquidInBowl();
                                    } else if (capturedStepReq.resultModel === 'tomatoChunks') {
                                        loadTomatoChunksOnBoard();
                                    }
                                }, 3000);
                            }
                            // Phase 2: Add to pan collection
                            else if (matchedStepReq.phase === 2) {
                                // Mark as collected in pan
                                if (draggedIngredientName === 'è›‹æ¶²') {
                                    phase2PanCollection.eggLiquid = true;
                                    // Remove from scene or hide
                                    if (draggedModel) scene.remove(draggedModel);
                                } else if (draggedIngredientName === 'ç•ªèŒ„å¡Š') {
                                    phase2PanCollection.tomatoChunks = true;
                                    if (draggedModel) scene.remove(draggedModel);
                                } else if (draggedIngredientName === 'èª¿å‘³ç½') {
                                    phase2PanCollection.seasoning = true;
                                } else if (draggedIngredientName === 'é†¬æ²¹ç½') {
                                    phase2PanCollection.soySauce = true;
                                }

                                console.log('Pan collection status:', phase2PanCollection);

                                // Check if all ingredients are collected
                                checkPanCompletion();
                            }
                            // Phase 3: Finishing touches
                            else if (matchedStepReq.phase === 3) {
                                // Scallion to pan - show timer and replace semi-finished with finished
                                if (draggedIngredientName === 'è”¥èŠ±') {
                                    console.log('âœ“ Scallion added to pan! Finishing dish...');

                                    const panModel = scene.getObjectByName('pan');
                                    if (panModel) {
                                        showTimerAnimation(panModel, 3000);
                                        setTimeout(() => {
                                            replaceSemiFinishedWithFinished();
                                        }, 3000);
                                    }
                                }
                                // Finished product to plate
                                else if (draggedIngredientName === 'æˆå“') {
                                    console.log('âœ“ Finished product moved to plate!');

                                    // Get plate position
                                    const plateModel = scene.getObjectByName('plate');
                                    if (plateModel && draggedModel) {
                                        const box = new THREE.Box3().setFromObject(plateModel);
                                        const center = box.getCenter(new THREE.Vector3());
                                        const max = box.max;

                                        // Position finished product on plate
                                        draggedModel.position.set(
                                            center.x,
                                            max.y + 0.02,  // On plate surface
                                            center.z
                                        );

                                        // Scale up by 125% when on plate (0.4 â†’ 0.9)
                                        draggedModel.scale.set(0.9, 0.9, 0.9);

                                        console.log('ğŸ‰ Task completed! Dish is now on the plate!');

                                        // Add score for placing finished product on plate
                                        if (window.addScore) window.addScore(20);

                                        // Wait 3 seconds then go to results screen
                                        setTimeout(() => {
                                            console.log('Transitioning to results screen...');
                                            showResultsScreen();
                                        }, 3000);
                                    }
                                }
                            }
                        } else {
                            // WRONG! Show error X
                            console.log(`âœ— Wrong! ${draggedIngredientName} should not go to ${targetName}`);
                            showErrorAnimation(targetObject);

                            // Return ingredient to panel or original position
                            if (draggedIngredientElement) {
                                // Panel ingredient - return to panel
                                draggedIngredientElement.remove();
                                ingredientsList.appendChild(draggedIngredientElement);
                                draggedIngredientElement.style.display = '';
                            } else if (draggedModel && draggedModel.userData.originalPosition) {
                                // Scene model - return to original position
                                draggedModel.position.copy(draggedModel.userData.originalPosition);
                            }
                        }
                    } else {
                        // Dropped outside - return to ingredient panel or original position
                        console.log(`${draggedIngredientName} dropped outside - returning`);
                        if (draggedIngredientElement) {
                            // Panel ingredient - return to panel
                            draggedIngredientElement.remove();
                            ingredientsList.appendChild(draggedIngredientElement);
                            draggedIngredientElement.style.display = '';
                        } else if (draggedModel && draggedModel.userData.originalPosition) {
                            // Scene model - return to original position
                            draggedModel.position.copy(draggedModel.userData.originalPosition);
                        }
                    }

                    // Clean up dragged model (only if from panel)
                    if (draggedIngredientElement && draggedModel) {
                        scene.remove(draggedModel);
                        draggedModel = null;
                    }

                    // Reset dragging state
                    isDragging = false;
                    draggedIngredientName = null;
                    draggedIngredientElement = null;

                    // Re-enable OrbitControls
                    controls.enabled = true;
                }

                // Show timer animation above target object (neon gaming style)
                function showTimerAnimation(targetModel, duration = 3000) {
                    // Get target position
                    const box = new THREE.Box3().setFromObject(targetModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    // Position timer at fixed height above objects (consistent for all)
                    const timerPosition = new THREE.Vector3(
                        center.x,
                        0.3, // Fixed height for consistent timer position
                        center.z
                    );

                    // Create timer sprite
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');

                    // Animation variables
                    const startTime = Date.now();
                    let animationFrame = null;

                    function drawTimer() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Clear canvas
                        ctx.clearRect(0, 0, 256, 256);

                        // Draw neon gaming style timer
                        ctx.save();
                        ctx.translate(128, 128);

                        // Outer glow effect (cyan)
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#00ffff';

                        // Outer neon cyan ring
                        ctx.beginPath();
                        ctx.arc(0, 0, 100, 0, Math.PI * 2);
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 6;
                        ctx.stroke();

                        // Inner glow ring
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.arc(0, 0, 92, 0, Math.PI * 2);
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // Dark background
                        ctx.shadowBlur = 0;
                        ctx.beginPath();
                        ctx.arc(0, 0, 88, 0, Math.PI * 2);
                        ctx.fillStyle = '#0a0a0a';
                        ctx.fill();

                        // Progress arc (pink/magenta neon)
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ff00ff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 75, -Math.PI / 2, -Math.PI / 2 + (progress * Math.PI * 2));
                        ctx.strokeStyle = '#ff00ff';
                        ctx.lineWidth = 8;
                        ctx.lineCap = 'round';
                        ctx.stroke();

                        // Clock marks (12 positions) - cyan dots
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#00ffff';
                        ctx.fillStyle = '#00ffff';
                        for (let i = 0; i < 12; i++) {
                            const angle = (i * 30 - 90) * Math.PI / 180;
                            const x = Math.cos(angle) * 65;
                            const y = Math.sin(angle) * 65;
                            ctx.beginPath();
                            ctx.arc(x, y, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Moving hand (pink/magenta with glow)
                        const handAngle = -Math.PI / 2 + (progress * Math.PI * 2);
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff00ff';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(handAngle) * 60, Math.sin(handAngle) * 60);
                        ctx.strokeStyle = '#ff00ff';
                        ctx.lineWidth = 5;
                        ctx.lineCap = 'round';
                        ctx.stroke();

                        // Center dot with glow
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#00ffff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8, 0, Math.PI * 2);
                        ctx.fillStyle = '#00ffff';
                        ctx.fill();

                        // Inner center dot
                        ctx.shadowBlur = 0;
                        ctx.beginPath();
                        ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        ctx.fillStyle = '#ffffff';
                        ctx.fill();

                        // Digital countdown text (center)
                        const remainingSeconds = Math.ceil((duration - elapsed) / 1000);
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#00ffff';
                        ctx.fillStyle = '#00ffff';
                        ctx.font = 'bold 32px Orbitron, monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(remainingSeconds.toString(), 0, 0);

                        ctx.restore();

                        // Update texture
                        texture.needsUpdate = true;

                        if (progress < 1) {
                            animationFrame = requestAnimationFrame(drawTimer);
                        } else {
                            // Animation complete - remove sprite
                            setTimeout(() => {
                                scene.remove(sprite);
                                texture.dispose();
                                material.dispose();
                            }, 200);
                        }
                    }

                    // Create sprite
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 0.95
                    });
                    const sprite = new THREE.Sprite(material);
                    sprite.position.copy(timerPosition);
                    sprite.scale.set(0.6, 0.6, 1); // Slightly larger for visibility
                    scene.add(sprite);

                    // Start animation
                    drawTimer();
                }

                // Show error X animation
                function showErrorAnimation(targetModel) {
                    // Get target position
                    const box = new THREE.Box3().setFromObject(targetModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());

                    // Position X above the object
                    const errorPosition = new THREE.Vector3(
                        center.x,
                        center.y + size.y * 0.7,
                        center.z
                    );

                    // Create error X sprite
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 256;
                    const ctx = canvas.getContext('2d');

                    // Draw red X
                    ctx.clearRect(0, 0, 256, 256);

                    // Red circle background
                    ctx.beginPath();
                    ctx.arc(128, 128, 100, 0, Math.PI * 2);
                    ctx.fillStyle = '#FF0000';
                    ctx.fill();

                    // White X
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 20;
                    ctx.lineCap = 'round';

                    // First line of X
                    ctx.beginPath();
                    ctx.moveTo(70, 70);
                    ctx.lineTo(186, 186);
                    ctx.stroke();

                    // Second line of X
                    ctx.beginPath();
                    ctx.moveTo(186, 70);
                    ctx.lineTo(70, 186);
                    ctx.stroke();

                    // Create sprite
                    const texture = new THREE.CanvasTexture(canvas);
                    const material = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: 1
                    });
                    const sprite = new THREE.Sprite(material);
                    sprite.position.copy(errorPosition);
                    sprite.scale.set(0.5, 0.5, 1);
                    scene.add(sprite);

                    // Flash animation (fade in/out quickly)
                    let flashCount = 0;
                    const flashInterval = setInterval(() => {
                        sprite.material.opacity = sprite.material.opacity > 0.5 ? 0.3 : 1;
                        flashCount++;

                        if (flashCount >= 6) { // 3 flashes
                            clearInterval(flashInterval);
                            // Fade out and remove
                            let fadeOut = setInterval(() => {
                                sprite.material.opacity -= 0.1;
                                if (sprite.material.opacity <= 0) {
                                    clearInterval(fadeOut);
                                    scene.remove(sprite);
                                    texture.dispose();
                                    material.dispose();
                                }
                            }, 30);
                        }
                    }, 150);
                }

                // [REMOVED] Smoke animation function removed to reduce performance load
                /* function showSmokeAnimation(targetModel, duration = 3000) {
                    // Get target position (center of the bowl)
                    const box = new THREE.Box3().setFromObject(targetModel);
                    const center = box.getCenter(new THREE.Vector3());
 
                    // Create multiple smoke particles
                    const smokeParticles = [];
                    const particleCount = 8;
 
                    for (let i = 0; i < particleCount; i++) {
                        const canvas = document.createElement('canvas');
                        canvas.width = 128;
                        canvas.height = 128;
                        const ctx = canvas.getContext('2d');
 
                        // Draw smoke particle (soft white/gray circle with gradient)
                        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
                        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(200, 200, 200, 0.4)');
                        gradient.addColorStop(1, 'rgba(150, 150, 150, 0)');
 
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 128, 128);
 
                        // Create sprite
                        const texture = new THREE.CanvasTexture(canvas);
                        const material = new THREE.SpriteMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 0
                        });
                        const sprite = new THREE.Sprite(material);
 
                        // Position at bowl center with slight random offset
                        const offsetX = (Math.random() - 0.5) * 0.1;
                        const offsetZ = (Math.random() - 0.5) * 0.1;
                        sprite.position.set(
                            center.x + offsetX,
                            center.y,
                            center.z + offsetZ
                        );
 
                        const baseScale = 0.2 + Math.random() * 0.15;
                        sprite.scale.set(baseScale, baseScale, 1);
 
                        scene.add(sprite);
 
                        smokeParticles.push({
                            sprite: sprite,
                            texture: texture,
                            material: material,
                            startY: center.y,
                            riseSpeed: 0.0003 + Math.random() * 0.0002,
                            rotationSpeed: (Math.random() - 0.5) * 0.02,
                            delay: i * 100, // Stagger particle appearance
                            maxScale: baseScale * (1.5 + Math.random() * 0.5)
                        });
                    }
 
                    // Animate smoke particles
                    const startTime = Date.now();
 
                    function animateSmoke() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
 
                        let allComplete = true;
 
                        smokeParticles.forEach((particle, index) => {
                            const particleElapsed = elapsed - particle.delay;
 
                            if (particleElapsed > 0) {
                                const particleProgress = Math.min(particleElapsed / (duration - particle.delay), 1);
 
                                // Rise up
                                particle.sprite.position.y = particle.startY + particleProgress * 0.5;
 
                                // Expand
                                const scale = particle.sprite.scale.x + (particle.maxScale - particle.sprite.scale.x) * 0.02;
                                particle.sprite.scale.set(scale, scale, 1);
 
                                // Fade in then fade out
                                if (particleProgress < 0.3) {
                                    particle.material.opacity = particleProgress / 0.3 * 0.7;
                                } else {
                                    particle.material.opacity = (1 - particleProgress) * 0.7;
                                }
 
                                if (particleProgress < 1) {
                                    allComplete = false;
                                }
                            } else {
                                allComplete = false;
                            }
                        });
 
                        if (!allComplete) {
                            requestAnimationFrame(animateSmoke);
                        } else {
                            // Clean up all particles
                            smokeParticles.forEach(particle => {
                                scene.remove(particle.sprite);
                                particle.texture.dispose();
                                particle.material.dispose();
                            });
                        }
                    }
 
                    animateSmoke();
                } */


                // Load egg liquid model in bowl
                let eggLiquidModel = null;
                function loadEggLiquidInBowl() {
                    console.log('=== Starting to load egg liquid model ===');
                    const eggLiquidURL = 'assets/model/è›‹æ¶².glb';

                    gltfLoader.load(eggLiquidURL, (gltf) => {
                        const object = gltf.scene;
                        console.log('âœ“ Egg liquid FBX file loaded successfully');
                        eggLiquidModel = object;

                        // Get bowl position to place egg liquid
                        if (bowlModel) {
                            const box = new THREE.Box3().setFromObject(bowlModel);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());

                            console.log('Bowl info:', {
                                center: { x: center.x.toFixed(2), y: center.y.toFixed(2), z: center.z.toFixed(2) },
                                size: { x: size.x.toFixed(2), y: size.y.toFixed(2), z: size.z.toFixed(2) }
                            });

                            // Position egg liquid at bowl bottom
                            const min = box.min;
                            eggLiquidModel.position.set(
                                center.x,
                                min.y + 0.32, // At bowl bottom (raised by 0.3 from original 0.02)
                                center.z
                            );

                            // Use appropriate scale for egg liquid
                            eggLiquidModel.scale.set(0.72, 0.72, 0.72);

                            eggLiquidModel.name = 'eggLiquid';

                            scene.add(eggLiquidModel);

                            // Simplified logging
                            console.log('âœ“ Egg liquid model added to scene');
                            console.log('Position:', eggLiquidModel.position);
                            console.log('Scale:', eggLiquidModel.scale);
                            console.log('=== Egg liquid model setup complete ===');

                            // Mark as draggable for phase 2
                            eggLiquidModel.userData.isDraggable = true;
                            eggLiquidModel.userData.ingredientName = 'è›‹æ¶²';
                            eggLiquidModel.userData.originalPosition = eggLiquidModel.position.clone();

                            // Mark phase 1 egg liquid as completed
                            phase1Completed.eggLiquid = true;

                            // Add score for completing egg liquid
                            if (window.addScore) window.addScore(20);
                            checkPhase1Completion();
                        } else {
                            console.error('âœ— Bowl model not found, cannot position egg liquid');
                        }
                    }, (xhr) => {
                        // Progress callback
                        if (xhr.lengthComputable) {
                            const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(0);
                            console.log(`Loading egg liquid: ${percentComplete}%`);
                        }
                    }, (err) => {
                        console.error('âœ— Egg liquid model load error:', err);
                    });
                }

                // Load tomato chunks model on cutting board
                let tomatoChunksModel = null;
                function loadTomatoChunksOnBoard() {
                    console.log('=== Starting to load tomato chunks model ===');
                    const tomatoChunksURL = 'assets/model/ç•ªèŒ„å¡Š.glb';

                    gltfLoader.load(tomatoChunksURL, (gltf) => {
                        const object = gltf.scene;
                        console.log('âœ“ Tomato chunks FBX file loaded successfully');
                        tomatoChunksModel = object;

                        // Get cutting board position to place tomato chunks
                        if (cuttingBoardModel) {
                            const box = new THREE.Box3().setFromObject(cuttingBoardModel);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());

                            console.log('Cutting board info:', {
                                center: { x: center.x.toFixed(2), y: center.y.toFixed(2), z: center.z.toFixed(2) },
                                size: { x: size.x.toFixed(2), y: size.y.toFixed(2), z: size.z.toFixed(2) }
                            });

                            // Position tomato chunks on cutting board surface (raised for visibility)
                            const max = box.max;
                            tomatoChunksModel.position.set(
                                center.x,
                                max.y + 0.03, // Adjusted Y position (lowered by 0.05 from previous 0.08)
                                center.z
                            );

                            // Use appropriate scale for tomato chunks (increased by 50% for better visibility)
                            tomatoChunksModel.scale.set(0.525, 0.525, 0.525);

                            tomatoChunksModel.name = 'tomatoChunks';

                            scene.add(tomatoChunksModel);

                            // Simplified logging
                            console.log('âœ“ Tomato chunks model added to scene');
                            console.log('Position:', tomatoChunksModel.position);
                            console.log('Scale:', tomatoChunksModel.scale);
                            console.log('=== Tomato chunks model setup complete ===');

                            // Mark as draggable for phase 2
                            tomatoChunksModel.userData.isDraggable = true;
                            tomatoChunksModel.userData.ingredientName = 'ç•ªèŒ„å¡Š';
                            tomatoChunksModel.userData.originalPosition = tomatoChunksModel.position.clone();

                            // Mark phase 1 tomato chunks as completed
                            phase1Completed.tomatoChunks = true;

                            // Add score for completing tomato chunks
                            if (window.addScore) window.addScore(20);

                            checkPhase1Completion();
                        } else {
                            console.error('âœ— Cutting board model not found, cannot position tomato chunks');
                        }
                    }, (xhr) => {
                        // Progress callback
                        if (xhr.lengthComputable) {
                            const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(0);
                            console.log(`Loading tomato chunks: ${percentComplete}%`);
                        }
                    }, (err) => {
                        console.error('âœ— Tomato chunks model load error:', err);
                    });
                }

                // Check if all ingredients are in the pan
                function checkPanCompletion() {
                    if (phase2PanCollection.eggLiquid &&
                        phase2PanCollection.tomatoChunks &&
                        phase2PanCollection.seasoning &&
                        phase2PanCollection.soySauce) {
                        console.log('ğŸ‰ All ingredients collected in pan! Starting countdown...');

                        const panModel = scene.getObjectByName('pan');
                        if (panModel) {
                            showTimerAnimation(panModel, 3000);
                            setTimeout(() => {
                                loadSemiFinishedProduct();

                                // Add score for completing semi-finished product
                                if (window.addScore) window.addScore(20);

                                // Move to phase 3 after semi-finished product is loaded
                                setTimeout(() => {
                                    currentPhase = 3;
                                    updateCookingInstructionsPhase3();
                                }, 500);
                            }, 3000);
                        }
                    }
                }

                // Load semi-finished product on pan
                let semiFinishedModel = null;
                function loadSemiFinishedProduct() {
                    console.log('=== Starting to load semi-finished product model ===');
                    const semiFinishedURL = 'assets/model/åŠæˆå“.glb';

                    gltfLoader.load(semiFinishedURL, (gltf) => {
                        const object = gltf.scene;
                        console.log('âœ“ Semi-finished product loaded');
                        semiFinishedModel = object;

                        const panModel = scene.getObjectByName('pan');
                        if (panModel) {
                            const box = new THREE.Box3().setFromObject(panModel);
                            const center = box.getCenter(new THREE.Vector3());
                            const max = box.max;


                            // Position adjusted based on user feedback
                            semiFinishedModel.position.set(
                                center.x + 0.2 - 0.05,          // X: +0.15
                                max.y + 0.05 - 1 + 0.5 + 0.18,  // Y: -0.27 (was -0.45, now +0.18)
                                center.z + 0.5 - 0.5 - 0.1      // Z: -0.1
                            );
                            semiFinishedModel.scale.set(0.4, 0.4, 0.4);
                            semiFinishedModel.name = 'semiFinished';
                            scene.add(semiFinishedModel);
                            console.log('âœ“ Semi-finished product added to scene');
                            console.log('ğŸ“ Semi-finished product coordinates:');
                            console.log('  Position:', {
                                x: semiFinishedModel.position.x.toFixed(3),
                                y: semiFinishedModel.position.y.toFixed(3),
                                z: semiFinishedModel.position.z.toFixed(3)
                            });
                            console.log('  Scale:', {
                                x: semiFinishedModel.scale.x,
                                y: semiFinishedModel.scale.y,
                                z: semiFinishedModel.scale.z
                            });
                        }
                    }, undefined, (err) => {
                        console.error('âœ— Semi-finished product load error:', err);
                    });
                }

                // Replace semi-finished product with finished product
                let finishedModel = null;
                function replaceSemiFinishedWithFinished() {
                    console.log('=== Replacing semi-finished with finished product ===');

                    // Remove semi-finished product
                    if (semiFinishedModel) {
                        const semiPosition = semiFinishedModel.position.clone();
                        scene.remove(semiFinishedModel);
                        console.log('âœ“ Semi-finished product removed');

                        // Load finished product
                        const finishedURL = 'assets/model/æˆå“.glb';
                        gltfLoader.load(finishedURL, (gltf) => {
                            const object = gltf.scene;
                            console.log('âœ“ Finished product loaded');
                            finishedModel = object;

                            // Use same position and scale as semi-finished
                            finishedModel.position.copy(semiPosition);
                            finishedModel.scale.set(0.4, 0.4, 0.4);
                            finishedModel.name = 'finished';

                            // Mark as draggable for moving to plate
                            finishedModel.userData.isDraggable = true;
                            finishedModel.userData.ingredientName = 'æˆå“';
                            finishedModel.userData.originalPosition = finishedModel.position.clone();

                            scene.add(finishedModel);

                            // Add score for completing finished product
                            if (window.addScore) window.addScore(20);

                            console.log('âœ“ Finished product added to scene');
                            console.log('ğŸ‰ Dish completed!');
                        }, undefined, (err) => {
                            console.error('âœ— Finished product load error:', err);
                        });
                    }
                }

                // Check if Phase 1 is completed
                function checkPhase1Completion() {
                    if (phase1Completed.eggLiquid && phase1Completed.tomatoChunks) {
                        console.log('ğŸ‰ Phase 1 completed! Moving to Phase 2...');
                        currentPhase = 2;
                        updateCookingInstructions();
                    }
                }

                // Update cooking instructions UI
                function updateCookingInstructions() {
                    const phaseTitle = document.getElementById('cookingPhaseTitle');
                    const stepsContent = document.getElementById('cookingStepsContent');

                    if (currentPhase === 2) {
                        phaseTitle.textContent = 'ç¬¬äºŒéšæ®µï¼šåˆ†æ¬¡å…¥é‹';
                        stepsContent.innerHTML = `
                            <div class="flex gap-3 p-3 bg-black bg-opacity-50 rounded-lg border border-cyan-400 border-opacity-30">
                                <div class="flex-shrink-0">
                                    <div class="w-8 h-8 rounded-full bg-cyan-400 bg-opacity-20 flex items-center justify-center">
                                        <span class="text-cyan-400 font-bold">3</span>
                                    </div>
                                </div>
                                <div class="flex-1 text-sm leading-relaxed">
                                    å°‡ã€<span class="text-yellow-300 font-semibold">è›‹æ¶²</span>ã€‘å¾å¤§ç¢—æ‹–ç§»è‡³ã€<span class="text-orange-400 font-semibold">å¹³åº•é‹</span>ã€‘ã€‚
                                </div>
                            </div>
                            <div class="flex gap-3 p-3 bg-black bg-opacity-50 rounded-lg border border-cyan-400 border-opacity-30">
                                <div class="flex-shrink-0">
                                    <div class="w-8 h-8 rounded-full bg-cyan-400 bg-opacity-20 flex items-center justify-center">
                                        <span class="text-cyan-400 font-bold">4</span>
                                    </div>
                                </div>
                                <div class="flex-1 text-sm leading-relaxed">
                                    å°‡ã€<span class="text-red-400 font-semibold">ç•ªèŒ„å¡Š</span>ã€‘å¾ç §æ¿æ‹–ç§»è‡³ã€<span class="text-orange-400 font-semibold">å¹³åº•é‹</span>ã€‘ã€‚
                                </div>
                            </div>
                            <div class="flex gap-3 p-3 bg-black bg-opacity-50 rounded-lg border border-cyan-400 border-opacity-30">
                                <div class="flex-shrink-0">
                                    <div class="w-8 h-8 rounded-full bg-cyan-400 bg-opacity-20 flex items-center justify-center">
                                        <span class="text-cyan-400 font-bold">5</span>
                                    </div>
                                </div>
                                <div class="flex-1 text-sm leading-relaxed">
                                    å°‡ã€<span class="text-yellow-400 font-semibold">èª¿å‘³ç½</span>ã€‘èˆ‡ã€<span class="text-amber-700 font-semibold">é†¬æ²¹ç½</span>ã€‘å¾æ¬„ä½æ‹–ç§»è‡³ã€<span class="text-orange-400 font-semibold">å¹³åº•é‹</span>ã€‘ã€‚
                                </div>
                            </div>
                        `;
                        console.log('âœ“ Cooking instructions updated to Phase 2');
                    }
                }

                // Update cooking instructions to Phase 3
                function updateCookingInstructionsPhase3() {
                    const phaseTitle = document.getElementById('cookingPhaseTitle');
                    const stepsContent = document.getElementById('cookingStepsContent');

                    phaseTitle.textContent = 'ç¬¬ä¸‰éšæ®µï¼šæ··åˆèµ·é‹';
                    stepsContent.innerHTML = `
                        <div class="flex gap-3 p-3 bg-black bg-opacity-50 rounded-lg border border-cyan-400 border-opacity-30">
                            <div class="flex-shrink-0">
                                <div class="w-8 h-8 rounded-full bg-cyan-400 bg-opacity-20 flex items-center justify-center">
                                    <span class="text-cyan-400 font-bold">6</span>
                                </div>
                            </div>
                            <div class="flex-1 text-sm leading-relaxed">
                                å°‡ã€<span class="text-green-400 font-semibold">è”¥èŠ±</span>ã€‘å¾æ¬„ä½æ‹–ç§»è‡³ã€<span class="text-orange-400 font-semibold">å¹³åº•é‹</span>ã€‘é€²è¡Œé»ç¶´ã€‚
                            </div>
                        </div>
                        <div class="flex gap-3 p-3 bg-black bg-opacity-50 rounded-lg border border-cyan-400 border-opacity-30">
                            <div class="flex-shrink-0">
                                <div class="w-8 h-8 rounded-full bg-cyan-400 bg-opacity-20 flex items-center justify-center">
                                    <span class="text-cyan-400 font-bold">7</span>
                                </div>
                            </div>
                            <div class="flex-1 text-sm leading-relaxed">
                                å°‡æ•´å€‹ã€<span class="text-yellow-300 font-semibold">ç•ªèŒ„ç‚’è›‹</span>ã€‘æ‹–ç§»è‡³ã€<span class="text-gray-300 font-semibold">ç™½è‰²åœ“ç›¤</span>ã€‘ã€‚ä»»å‹™å®Œæˆï¼
                            </div>
                        </div>
                    `;
                    console.log('âœ“ Cooking instructions updated to Phase 3');
                }

                // Load white ceramic bowl model
                let bowlModel = null; // Store bowl model reference for interaction
                const bowlURL = 'assets/model/ç™½è‰²é™¶ç“·ç¢—.glb';
                gltfLoader.load(bowlURL, (gltf) => {
                    bowlModel = gltf.scene;
                    bowlModel.scale.set(1, 1, 1); // Keep original size
                    bowlModel.position.set(0.9, -0.5, -0.5); // Position at specified location
                    bowlModel.name = 'bowl'; // Set name for identification

                    // Apply white ceramic material to all meshes in the bowl
                    bowlModel.traverse((child) => {
                        if (child.isMesh) {
                            // Create white ceramic material
                            child.material = new THREE.MeshStandardMaterial({
                                color: 0xC6C6C6, // Gray ceramic color
                                roughness: 0.3, // Smooth ceramic surface
                                metalness: 0.1, // Slight metallic sheen
                                emissive: 0x000000, // No self-illumination
                                emissiveIntensity: 0
                            });
                        }
                    });

                    scene.add(bowlModel);
                    console.log('White ceramic bowl model loaded successfully with white material');
                }, undefined, (err) => {
                    console.error('White ceramic bowl load error', err);
                });

                // Load pan model (GLB)
                let panModel = null; // Store pan model reference for interaction
                const panURL = 'assets/model/å¹³åº•é‹.glb?v=' + Date.now();
                gltfLoader.load(panURL, (gltf) => {
                    panModel = gltf.scene;
                    panModel.scale.set(1, 1, 1); // Keep original size
                    panModel.position.set(-0.75, -0.67, -0.2); // Position at specified location
                    panModel.rotation.y = Math.PI * 3 / 4; // Rotate 135 degrees to the right (135Â° = 3Ï€/4 radians)
                    panModel.name = 'pan'; // Set name for identification
                    scene.add(panModel);
                    console.log('Pan model loaded successfully');
                }, undefined, (err) => {
                    console.error('Pan load error', err);
                });

                // upload / drag-n-drop
                const dropZone = document.getElementById('dropZone');
                const openFileBtn = document.getElementById('openFileBtn');
                const fileInput = document.getElementById('fileInput');
                openFileBtn && openFileBtn.addEventListener('click', () => fileInput.click());
                fileInput && fileInput.addEventListener('change', (e) => {
                    const f = e.target.files[0];
                    if (f) {
                        const reader = new FileReader();
                        reader.onload = (ev) => { loadGLBFromArrayBuffer(ev.target.result); if (dropZone) dropZone.style.display = 'none'; };
                        reader.readAsArrayBuffer(f);
                    }
                });

                container.addEventListener('dragover', (e) => { e.preventDefault(); if (dropZone) dropZone.style.display = 'flex'; });
                container.addEventListener('dragleave', (e) => { e.preventDefault(); if (e.relatedTarget == null || e.relatedTarget === document.body) if (dropZone) dropZone.style.display = 'none'; });
                container.addEventListener('drop', (e) => {
                    e.preventDefault(); if (dropZone) dropZone.style.display = 'none';
                    const dt = e.dataTransfer; if (!dt) return; const file = dt.files[0]; if (file) {
                        const reader = new FileReader();
                        reader.onload = (ev) => loadGLBFromArrayBuffer(ev.target.result);
                        reader.readAsArrayBuffer(file);
                    }
                });

                // Raycaster for mouse/touch interaction
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                let hoveredObject = null; // Track which object is currently hovered
                const originalEmissive = {}; // Store original emissive colors

                // Update mouse position
                function onPointerMove(event) {
                    // Calculate mouse position in normalized device coordinates (-1 to +1)
                    const rect = renderer.domElement.getBoundingClientRect();
                    let clientX, clientY;

                    if (event.touches && event.touches.length > 0) {
                        // Touch event
                        clientX = event.touches[0].clientX;
                        clientY = event.touches[0].clientY;
                    } else {
                        // Mouse event
                        clientX = event.clientX;
                        clientY = event.clientY;
                    }

                    mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                }


                // Add event listeners for both mouse and touch
                renderer.domElement.addEventListener('mousemove', onPointerMove, false);
                renderer.domElement.addEventListener('touchmove', onPointerMove, { passive: true });
                renderer.domElement.addEventListener('touchstart', onPointerMove, { passive: true });

                // Apply glow effect to a model
                function applyGlow(model) {
                    model.traverse((child) => {
                        if (child.isMesh && child.material) {
                            // Store original emissive color
                            if (!originalEmissive[child.uuid]) {
                                originalEmissive[child.uuid] = {
                                    color: child.material.emissive ? child.material.emissive.clone() : new THREE.Color(0x000000),
                                    intensity: child.material.emissiveIntensity || 0
                                };
                            }
                            // Apply dark blue glow
                            if (child.material.emissive) {
                                child.material.emissive.setHex(0x0044aa); // Dark blue
                                child.material.emissiveIntensity = 0.5; // Enhanced glow effect
                            }
                        }
                    });
                }

                // Remove glow effect from a model
                function removeGlow(model) {
                    model.traverse((child) => {
                        if (child.isMesh && child.material && originalEmissive[child.uuid]) {
                            if (child.material.emissive) {
                                child.material.emissive.copy(originalEmissive[child.uuid].color);
                                child.material.emissiveIntensity = originalEmissive[child.uuid].intensity;
                            }
                        }
                    });
                }

                // Check intersection and apply glow effect for all interactive objects
                function checkObjectsHover() {
                    // Update the raycaster with camera and mouse position
                    raycaster.setFromCamera(mouse, camera);

                    // Collect all interactive objects and their meshes
                    const interactiveObjects = [
                        { model: panModel, name: 'pan' },
                        { model: cuttingBoardModel, name: 'cuttingBoard' },
                        { model: bowlModel, name: 'bowl' },
                        { model: plateModel, name: 'plate' }
                    ];

                    let foundIntersection = false;
                    let intersectedObject = null;

                    // Check each object for intersection
                    for (const obj of interactiveObjects) {
                        if (!obj.model) continue;

                        const meshes = [];
                        obj.model.traverse((child) => {
                            if (child.isMesh) {
                                meshes.push(child);
                            }
                        });

                        const intersects = raycaster.intersectObjects(meshes, true);
                        if (intersects.length > 0) {
                            foundIntersection = true;
                            intersectedObject = obj.model;
                            break; // Only handle one object at a time
                        }
                    }

                    if (foundIntersection && intersectedObject) {
                        // Hovering over an object
                        if (hoveredObject !== intersectedObject) {
                            // Remove glow from previously hovered object
                            if (hoveredObject) {
                                removeGlow(hoveredObject);
                            }
                            // Apply glow to new object
                            hoveredObject = intersectedObject;
                            applyGlow(hoveredObject);
                            renderer.domElement.style.cursor = 'pointer';
                        }
                    } else {
                        // Not hovering over any object
                        if (hoveredObject) {
                            removeGlow(hoveredObject);
                            hoveredObject = null;
                            renderer.domElement.style.cursor = 'default';
                        }
                    }
                }

                function animate() {
                    requestAnimationFrame(animate);
                    checkObjectsHover(); // Check for objects hover on each frame
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();

                // ===== éŠæˆ²åˆå§‹åŒ–ï¼šè¼‰å…¥é£Ÿæ =====
                // åœ¨åŸºæœ¬å ´æ™¯è¼‰å…¥å®Œæˆå¾Œï¼Œè‡ªå‹•è¼‰å…¥é£Ÿæ
                setTimeout(() => {
                    if (!ingredientsLoaded) {
                        loadIngredients().then(() => {
                            console.log('ğŸ® éŠæˆ²æº–å‚™å®Œæˆï¼');
                        });
                    }
                }, 1000); // ç­‰å¾…1ç§’è®“åŸºæœ¬å ´æ™¯å…ˆè¼‰å…¥


                // Timer & Score
                let timerInterval = null;
                let timerStart = 0;
                let pausedOffset = 0;
                const timeElements = document.querySelectorAll('.time-value');

                function formatTime(ms) {
                    const totalSec = Math.floor(ms / 1000);
                    const mm = String(Math.floor(totalSec / 60)).padStart(2, '0');
                    const ss = String(totalSec % 60).padStart(2, '0');
                    return `${mm}:${ss}`;
                }

                function updateTimerDisplay() {
                    const elapsed = (Date.now() - timerStart) + pausedOffset;
                    timeElements.forEach(el => el.textContent = formatTime(elapsed));
                }

                function startTimer() {
                    if (timerInterval) return;
                    timerStart = Date.now();
                    timerInterval = setInterval(updateTimerDisplay, 250);
                    updateTimerDisplay();
                }

                function pauseTimer() {
                    if (!timerInterval) return;
                    clearInterval(timerInterval);
                    timerInterval = null;
                    pausedOffset += (Date.now() - timerStart);
                }

                function resetTimer() {
                    pauseTimer();
                    pausedOffset = 0;
                    timeElements.forEach(el => el.textContent = '00:00');
                }

                let totalSteps = 1;
                let perStep = 100;
                let currentScore = 0;
                const scoreElements = document.querySelectorAll('.score-value');

                function setSelectedRecipe(steps) {
                    totalSteps = Math.max(1, Number(steps) || 1);
                    perStep = 100 / totalSteps;
                    currentScore = 0;
                    updateScoreDisplay();
                }

                function updateScoreDisplay() {
                    const shown = Math.round(Math.min(100, currentScore));
                    scoreElements.forEach(el => el.textContent = `${shown} / 100`);
                }

                // Add fixed 20 points for each step completion
                window.addScore = function (points = 20) {
                    currentScore = Math.min(100, currentScore + points);
                    updateScoreDisplay();
                    console.log(`âœ“ Score +${points}! Current score: ${currentScore}/100`);
                };

                window.stepComplete = function () {
                    currentScore = Math.min(100, currentScore + perStep);
                    updateScoreDisplay();
                };

                function resetScore() {
                    currentScore = 0;
                    updateScoreDisplay();
                }

                // Expose current score for results screen
                window.getCurrentScore = function () {
                    return currentScore;
                };

                window.loadSceneFromURL = function (url) { loadGLBFromURL(url); };
                window.loadSceneFromArrayBuffer = function (ab) { loadGLBFromArrayBuffer(ab); };
                window.loadFBXFromURL = function (url) { loadFBXFromURL(url); };

                window.gameAPI = { startTimer, pauseTimer, resetTimer, setSelectedRecipe, resetScore, stepComplete, loadSceneFromURL, loadSceneFromArrayBuffer, loadFBXFromURL };
                window.forceThreeResize = function () { onWindowResize(); };
            })();
        </script>

        <script>
            // UI switching and settings modal logic
            (function () {
                const sections = ['home', 'recipes', 'gameplay', 'result', 'interaction'];
                function showSection(id) {
                    sections.forEach(sid => {
                        const el = document.getElementById(sid);
                        if (!el) return;
                        if (sid === id) el.style.removeProperty('display');
                        else el.style.display = 'none';
                    });
                    if (id === 'gameplay') {
                        if (typeof window.forceThreeResize === 'function') setTimeout(() => window.forceThreeResize(), 80);
                        else window.dispatchEvent(new Event('resize'));
                    }
                    console.log('[UI] showSection ->', id);
                }

                // modal helpers
                const modal = document.getElementById('settingsModal');
                function openModal() { if (!modal) return; modal.classList.add('show'); modal.setAttribute('aria-hidden', 'false'); }
                function closeModal() { if (!modal) return; modal.classList.remove('show'); modal.setAttribute('aria-hidden', 'true'); }

                document.addEventListener('DOMContentLoaded', () => {
                    // initial
                    sections.forEach(sid => { const el = document.getElementById(sid); if (!el) return; if (sid === 'home') el.style.removeProperty('display'); else el.style.display = 'none'; });

                    // start -> recipes
                    const startBtn = document.getElementById('startBtn');
                    startBtn && startBtn.addEventListener('click', (ev) => {
                        ev.preventDefault();
                        startBtn.classList.add('btn-primary'); startBtn.style.color = '#fff';
                        setTimeout(() => { startBtn.classList.remove('btn-primary'); startBtn.style.color = ''; }, 180);
                        showSection('recipes');
                    });

                    // back -> home
                    const backBtn = document.getElementById('backToHomeBtn');
                    backBtn && backBtn.addEventListener('click', (ev) => {
                        ev.preventDefault();
                        if (window.gameAPI) { window.gameAPI.resetTimer && window.gameAPI.resetTimer(); window.gameAPI.resetScore && window.gameAPI.resetScore(); }
                        showSection('home');
                    });

                    // choose recipe -> gameplay (single shared scene)
                    document.body.addEventListener('click', function (e) {
                        const btn = e.target.closest && e.target.closest('.choose-recipe-btn');
                        if (!btn) return;
                        e.preventDefault();
                        const steps = parseInt(btn.getAttribute('data-steps') || '1', 10);
                        console.log('[UI] choose recipe, steps=', steps);

                        // For other recipes -> Go to Gameplay
                        if (window.gameAPI && typeof window.gameAPI.setSelectedRecipe === 'function') {
                            window.gameAPI.setSelectedRecipe(steps);
                            window.gameAPI.resetScore && window.gameAPI.resetScore();
                            window.gameAPI.resetTimer && window.gameAPI.resetTimer();
                            window.gameAPI.startTimer && window.gameAPI.startTimer();
                        } else console.warn('gameAPI not ready');
                        showSection('gameplay');
                    });

                    // Hakka recipe button -> Show development modal
                    const devModal = document.getElementById('devModal');
                    const devModalClose = document.getElementById('devModalClose');

                    document.body.addEventListener('click', function (e) {
                        const btn = e.target.closest && e.target.closest('.hakka-recipe-btn');
                        if (!btn) return;
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('[UI] Hakka recipe clicked - showing dev modal');

                        // Show development modal
                        if (devModal) {
                            devModal.classList.add('show');
                            devModal.setAttribute('aria-hidden', 'false');
                        }
                    });

                    // Close development modal
                    if (devModalClose) {
                        devModalClose.addEventListener('click', function () {
                            if (devModal) {
                                devModal.classList.remove('show');
                                devModal.setAttribute('aria-hidden', 'true');
                            }
                        });
                    }

                    // Close modal when clicking backdrop
                    if (devModal) {
                        devModal.addEventListener('click', function (ev) {
                            if (ev.target === devModal) {
                                devModal.classList.remove('show');
                                devModal.setAttribute('aria-hidden', 'true');
                            }
                        });
                    }

                    // settings icon in gameplay (hamburger)
                    const gameSettingsBtn = document.getElementById('gameSettingsBtn');
                    gameSettingsBtn && gameSettingsBtn.addEventListener('click', (ev) => {
                        ev.preventDefault();
                        // pause timer when modal opens
                        if (window.gameAPI && typeof window.gameAPI.pauseTimer === 'function') window.gameAPI.pauseTimer();
                        openModal();
                    });

                    // modal buttons
                    const modalContinue = document.getElementById('modalContinue');
                    const modalAbandon = document.getElementById('modalAbandon');
                    const modalSettings = document.getElementById('modalSettings');

                    modalContinue && modalContinue.addEventListener('click', () => {
                        // resume timer and close
                        if (window.gameAPI && typeof window.gameAPI.startTimer === 'function') window.gameAPI.startTimer();
                        closeModal();
                    });

                    modalAbandon && modalAbandon.addEventListener('click', () => {
                        // reset and go back home
                        if (window.gameAPI) { window.gameAPI.resetTimer && window.gameAPI.resetTimer(); window.gameAPI.resetScore && window.gameAPI.resetScore(); }
                        closeModal();
                        showSection('home');
                    });

                    modalSettings && modalSettings.addEventListener('click', () => {
                        // placeholder: open settings view or show settings section
                        alert('è¨­å®šï¼šå°šæœªå¯¦ä½œè©³ç´°è¨­å®šé é¢ï¼ˆå¯åœ¨æ­¤åŠ å…¥éŸ³é‡/è§¸æ§/æ§åˆ¶é¸é …ï¼‰');
                    });

                    // close modal when clicking backdrop (outside modal)
                    modal && modal.addEventListener('click', (ev) => {
                        if (ev.target === modal) {
                            if (window.gameAPI && typeof window.gameAPI.startTimer === 'function') window.gameAPI.startTimer();
                            closeModal();
                        }
                    });

                    // simple feedback for main menu settings/about
                    const topSettings = document.getElementById('settingsBtn');
                    topSettings && topSettings.addEventListener('click', (e) => { e.preventDefault(); topSettings.classList.add('btn-primary'); topSettings.style.color = '#fff'; setTimeout(() => { topSettings.classList.remove('btn-primary'); topSettings.style.color = ''; }, 160); });
                    const aboutBtn = document.getElementById('aboutBtn');
                    aboutBtn && aboutBtn.addEventListener('click', (e) => { e.preventDefault(); aboutBtn.classList.add('btn-primary'); aboutBtn.style.color = '#fff'; setTimeout(() => { aboutBtn.classList.remove('btn-primary'); aboutBtn.style.color = ''; }, 160); });

                    // Show results screen function
                    window.showResultsScreen = function () {
                        // Pause background music and play success music
                        const bgMusic = document.getElementById('bgMusic');
                        const successMusic = document.getElementById('successMusic');

                        if (bgMusic) {
                            bgMusic.pause();
                            console.log('ğŸµ Background music paused for results screen');
                        }

                        if (successMusic) {
                            successMusic.volume = 0.6; // Set volume to 60%
                            successMusic.currentTime = 0; // Start from beginning
                            const playPromise = successMusic.play();
                            if (playPromise !== undefined) {
                                playPromise.then(() => {
                                    console.log('ğŸ‰ Success music started playing');
                                }).catch(error => {
                                    console.log('âš ï¸ Success music play prevented:', error);
                                });
                            }
                        }

                        // Get current score and time
                        const finalScore = window.getCurrentScore ? window.getCurrentScore() : 100;
                        const timeElements = document.querySelectorAll('.time-value');
                        const finalTime = timeElements.length > 0 ? timeElements[0].textContent : '00:00';

                        const resultsOverlay = document.createElement('div');
                        resultsOverlay.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0, 0, 0, 0.95);
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            z-index: 9999;
                        `;

                        resultsOverlay.innerHTML = `
                            <div class="neon-border bg-black bg-opacity-90 rounded-lg p-12" style="max-width: 600px; width: 90%;">
                                <h1 class="text-5xl font-bold neon-text-green mb-8 text-center">ä»»å‹™å®Œæˆï¼</h1>
                                <div class="text-2xl neon-text mb-8 text-center">ç•ªèŒ„ç‚’è›‹è£½ä½œæˆåŠŸ</div>
                                
                                <div class="space-y-6 mb-8">
                                    <div class="flex justify-between items-center p-4 bg-black bg-opacity-50 rounded-lg border border-cyan-400 border-opacity-30">
                                        <span class="text-xl text-cyan-400">â±ï¸ ç”¨æ™‚æ™‚é–“</span>
                                        <span class="text-2xl font-bold neon-text">${finalTime}</span>
                                    </div>
                                    
                                    <div class="flex justify-between items-center p-4 bg-black bg-opacity-50 rounded-lg border border-green-400 border-opacity-30">
                                        <span class="text-xl text-green-400">â­ è©•åˆ†</span>
                                        <span class="text-2xl font-bold neon-text-green">${finalScore} / 100</span>
                                    </div>
                                </div>
                                
                                <button id="restartGameBtn" class="w-full px-8 py-4 neon-border-green bg-black text-green-400 rounded-lg text-xl hover:bg-green-900 transition-all font-bold">
                                    é‡æ–°é–‹å§‹
                                </button>
                            </div>
                        `;

                        document.body.appendChild(resultsOverlay);

                        // Add event listener for restart button
                        const restartBtn = document.getElementById('restartGameBtn');
                        if (restartBtn) {
                            restartBtn.addEventListener('click', function () {
                                // Stop success music
                                if (successMusic) {
                                    successMusic.pause();
                                    successMusic.currentTime = 0;
                                }
                                // Resume background music if it was enabled
                                if (bgMusic && window.musicControl && window.musicControl.isMusicEnabled()) {
                                    bgMusic.play().catch(err => console.log('Background music resume error:', err));
                                }
                                location.reload();
                            });
                        }

                        console.log('âœ… Results screen displayed');
                    };

                });
            })();
        </script>
        <script src="assets/js/music-control.js"></script>
</body>

</html>